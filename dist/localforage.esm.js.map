{"version":3,"file":"localforage.esm.js","sources":["../src/utils/idb.js","../src/utils/createBlob.js","../src/utils/promise.js","../src/utils/executeCallback.js","../src/utils/executeTwoCallbacks.js","../src/utils/normalizeKey.js","../src/utils/getCallback.js","../src/drivers/indexeddb.js","../src/utils/isIndexedDBValid.js","../src/utils/serializer.js","../src/drivers/websql.js","../src/utils/isWebSQLValid.js","../src/drivers/localstorage.js","../src/utils/isLocalStorageValid.js","../src/utils/includes.js","../src/utils/isArray.js","../src/localforage.js"],"sourcesContent":["function getIDB() {\n    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */\n    try {\n        if (typeof indexedDB !== 'undefined') {\n            return indexedDB;\n        }\n        if (typeof webkitIndexedDB !== 'undefined') {\n            return webkitIndexedDB;\n        }\n        if (typeof mozIndexedDB !== 'undefined') {\n            return mozIndexedDB;\n        }\n        if (typeof OIndexedDB !== 'undefined') {\n            return OIndexedDB;\n        }\n        if (typeof msIndexedDB !== 'undefined') {\n            return msIndexedDB;\n        }\n    } catch (e) {\n        return;\n    }\n}\n\nvar idb = getIDB();\nexport default idb;\n","// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\nfunction createBlob(parts, properties) {\n    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n    parts = parts || [];\n    properties = properties || {};\n    try {\n        return new Blob(parts, properties);\n    } catch (e) {\n        if (e.name !== 'TypeError') {\n            throw e;\n        }\n        var Builder =\n            typeof BlobBuilder !== 'undefined'\n                ? BlobBuilder\n                : typeof MSBlobBuilder !== 'undefined'\n                  ? MSBlobBuilder\n                  : typeof MozBlobBuilder !== 'undefined'\n                    ? MozBlobBuilder\n                    : WebKitBlobBuilder;\n        var builder = new Builder();\n        for (var i = 0; i < parts.length; i += 1) {\n            builder.append(parts[i]);\n        }\n        return builder.getBlob(properties.type);\n    }\n}\n\nexport default createBlob;\n","// This is CommonJS because lie is an external dependency, so Rollup\n// can just ignore it.\nif (typeof Promise === 'undefined') {\n    // In the \"nopromises\" build this will just throw if you don't have\n    // a global promise object, but it would throw anyway later.\n    require('lie/polyfill');\n}\nexport default Promise;\n","function executeCallback(promise, callback) {\n    if (callback) {\n        promise.then(\n            function(result) {\n                callback(null, result);\n            },\n            function(error) {\n                callback(error);\n            }\n        );\n    }\n}\n\nexport default executeCallback;\n","function executeTwoCallbacks(promise, callback, errorCallback) {\n    if (typeof callback === 'function') {\n        promise.then(callback);\n    }\n\n    if (typeof errorCallback === 'function') {\n        promise.catch(errorCallback);\n    }\n}\n\nexport default executeTwoCallbacks;\n","export default function normalizeKey(key) {\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(`${key} used as a key, but it is not a string.`);\n        key = String(key);\n    }\n\n    return key;\n}\n","export default function getCallback() {\n    if (\n        arguments.length &&\n        typeof arguments[arguments.length - 1] === 'function'\n    ) {\n        return arguments[arguments.length - 1];\n    }\n}\n","import isIndexedDBValid from '../utils/isIndexedDBValid';\nimport createBlob from '../utils/createBlob';\nimport idb from '../utils/idb';\nimport Promise from '../utils/promise';\nimport executeCallback from '../utils/executeCallback';\nimport executeTwoCallbacks from '../utils/executeTwoCallbacks';\nimport normalizeKey from '../utils/normalizeKey';\nimport getCallback from '../utils/getCallback';\n\n// Some code originally from async_storage.js in\n// [Gaia](https://github.com/mozilla-b2g/gaia).\n\nconst DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';\nlet supportsBlobs;\nconst dbContexts = {};\nconst toString = Object.prototype.toString;\n\n// Transaction Modes\nconst READ_ONLY = 'readonly';\nconst READ_WRITE = 'readwrite';\n\n// Transform a binary string to an array buffer, because otherwise\n// weird stuff happens when you try to work with the binary string directly.\n// It is known.\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction _binStringToArrayBuffer(bin) {\n    var length = bin.length;\n    var buf = new ArrayBuffer(length);\n    var arr = new Uint8Array(buf);\n    for (var i = 0; i < length; i++) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return buf;\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\n// Code borrowed from PouchDB. See:\n// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js\n//\nfunction _checkBlobSupportWithoutCaching(idb) {\n    return new Promise(function(resolve) {\n        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);\n        var blob = createBlob(['']);\n        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n\n        txn.onabort = function(e) {\n            // If the transaction aborts now its due to not being able to\n            // write to the database, likely due to the disk being full\n            e.preventDefault();\n            e.stopPropagation();\n            resolve(false);\n        };\n\n        txn.oncomplete = function() {\n            var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n            var matchedEdge = navigator.userAgent.match(/Edge\\//);\n            // MS Edge pretends to be Chrome 42:\n            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n            resolve(\n                matchedEdge ||\n                    !matchedChrome ||\n                    parseInt(matchedChrome[1], 10) >= 43\n            );\n        };\n    }).catch(function() {\n        return false; // error, so assume unsupported\n    });\n}\n\nfunction _checkBlobSupport(idb) {\n    if (typeof supportsBlobs === 'boolean') {\n        return Promise.resolve(supportsBlobs);\n    }\n    return _checkBlobSupportWithoutCaching(idb).then(function(value) {\n        supportsBlobs = value;\n        return supportsBlobs;\n    });\n}\n\nfunction _deferReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Create a deferred object representing the current database operation.\n    var deferredOperation = {};\n\n    deferredOperation.promise = new Promise(function(resolve, reject) {\n        deferredOperation.resolve = resolve;\n        deferredOperation.reject = reject;\n    });\n\n    // Enqueue the deferred operation.\n    dbContext.deferredOperations.push(deferredOperation);\n\n    // Chain its promise to the database readiness.\n    if (!dbContext.dbReady) {\n        dbContext.dbReady = deferredOperation.promise;\n    } else {\n        dbContext.dbReady = dbContext.dbReady.then(function() {\n            return deferredOperation.promise;\n        });\n    }\n}\n\nfunction _advanceReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Dequeue a deferred operation.\n    var deferredOperation = dbContext.deferredOperations.pop();\n\n    // Resolve its promise (which is part of the database readiness\n    // chain of promises).\n    if (deferredOperation) {\n        deferredOperation.resolve();\n        return deferredOperation.promise;\n    }\n}\n\nfunction _rejectReadiness(dbInfo, err) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Dequeue a deferred operation.\n    var deferredOperation = dbContext.deferredOperations.pop();\n\n    // Reject its promise (which is part of the database readiness\n    // chain of promises).\n    if (deferredOperation) {\n        deferredOperation.reject(err);\n        return deferredOperation.promise;\n    }\n}\n\nfunction _getConnection(dbInfo, upgradeNeeded) {\n    return new Promise(function(resolve, reject) {\n        dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();\n\n        if (dbInfo.db) {\n            if (upgradeNeeded) {\n                _deferReadiness(dbInfo);\n                dbInfo.db.close();\n            } else {\n                return resolve(dbInfo.db);\n            }\n        }\n\n        var dbArgs = [dbInfo.name];\n\n        if (upgradeNeeded) {\n            dbArgs.push(dbInfo.version);\n        }\n\n        var openreq = idb.open.apply(idb, dbArgs);\n\n        if (upgradeNeeded) {\n            openreq.onupgradeneeded = function(e) {\n                var db = openreq.result;\n                try {\n                    db.createObjectStore(dbInfo.storeName);\n                    if (e.oldVersion <= 1) {\n                        // Added when support for blob shims was added\n                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n                    }\n                } catch (ex) {\n                    if (ex.name === 'ConstraintError') {\n                        console.warn(\n                            'The database \"' +\n                                dbInfo.name +\n                                '\"' +\n                                ' has been upgraded from version ' +\n                                e.oldVersion +\n                                ' to version ' +\n                                e.newVersion +\n                                ', but the storage \"' +\n                                dbInfo.storeName +\n                                '\" already exists.'\n                        );\n                    } else {\n                        throw ex;\n                    }\n                }\n            };\n        }\n\n        openreq.onerror = function(e) {\n            e.preventDefault();\n            reject(openreq.error);\n        };\n\n        openreq.onsuccess = function() {\n            var db = openreq.result;\n            db.onversionchange = function(e) {\n                // Triggered when the database is modified (e.g. adding an objectStore) or\n                // deleted (even when initiated by other sessions in different tabs).\n                // Closing the connection here prevents those operations from being blocked.\n                // If the database is accessed again later by this instance, the connection\n                // will be reopened or the database recreated as needed.\n                e.target.close();\n            };\n            resolve(db);\n            _advanceReadiness(dbInfo);\n        };\n    });\n}\n\nfunction _getOriginalConnection(dbInfo) {\n    return _getConnection(dbInfo, false);\n}\n\nfunction _getUpgradedConnection(dbInfo) {\n    return _getConnection(dbInfo, true);\n}\n\nfunction _isUpgradeNeeded(dbInfo, defaultVersion) {\n    if (!dbInfo.db) {\n        return true;\n    }\n\n    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);\n    var isDowngrade = dbInfo.version < dbInfo.db.version;\n    var isUpgrade = dbInfo.version > dbInfo.db.version;\n\n    if (isDowngrade) {\n        // If the version is not the default one\n        // then warn for impossible downgrade.\n        if (dbInfo.version !== defaultVersion) {\n            console.warn(\n                'The database \"' +\n                    dbInfo.name +\n                    '\"' +\n                    \" can't be downgraded from version \" +\n                    dbInfo.db.version +\n                    ' to version ' +\n                    dbInfo.version +\n                    '.'\n            );\n        }\n        // Align the versions to prevent errors.\n        dbInfo.version = dbInfo.db.version;\n    }\n\n    if (isUpgrade || isNewStore) {\n        // If the store is new then increment the version (if needed).\n        // This will trigger an \"upgradeneeded\" event which is required\n        // for creating a store.\n        if (isNewStore) {\n            var incVersion = dbInfo.db.version + 1;\n            if (incVersion > dbInfo.version) {\n                dbInfo.version = incVersion;\n            }\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n// encode a blob for indexeddb engines that don't support blobs\nfunction _encodeBlob(blob) {\n    return new Promise(function(resolve, reject) {\n        var reader = new FileReader();\n        reader.onerror = reject;\n        reader.onloadend = function(e) {\n            var base64 = btoa(e.target.result || '');\n            resolve({\n                __local_forage_encoded_blob: true,\n                data: base64,\n                type: blob.type\n            });\n        };\n        reader.readAsBinaryString(blob);\n    });\n}\n\n// decode an encoded blob\nfunction _decodeBlob(encodedBlob) {\n    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));\n    return createBlob([arrayBuff], { type: encodedBlob.type });\n}\n\n// is this one of our fancy encoded blobs?\nfunction _isEncodedBlob(value) {\n    return value && value.__local_forage_encoded_blob;\n}\n\n// Specialize the default `ready()` function by making it dependent\n// on the current database operations. Thus, the driver will be actually\n// ready when it's been initialized (default) *and* there are no pending\n// operations on the database (initiated by some other instances).\nfunction _fullyReady(callback) {\n    var self = this;\n\n    var promise = self._initReady().then(function() {\n        var dbContext = dbContexts[self._dbInfo.name];\n\n        if (dbContext && dbContext.dbReady) {\n            return dbContext.dbReady;\n        }\n    });\n\n    executeTwoCallbacks(promise, callback, callback);\n    return promise;\n}\n\n// Try to establish a new db connection to replace the\n// current one which is broken (i.e. experiencing\n// InvalidStateError while creating a transaction).\nfunction _tryReconnect(dbInfo) {\n    _deferReadiness(dbInfo);\n\n    var dbContext = dbContexts[dbInfo.name];\n    var forages = dbContext.forages;\n\n    for (var i = 0; i < forages.length; i++) {\n        const forage = forages[i];\n        if (forage._dbInfo.db) {\n            forage._dbInfo.db.close();\n            forage._dbInfo.db = null;\n        }\n    }\n    dbInfo.db = null;\n\n    return _getOriginalConnection(dbInfo)\n        .then(db => {\n            dbInfo.db = db;\n            if (_isUpgradeNeeded(dbInfo)) {\n                // Reopen the database for upgrading.\n                return _getUpgradedConnection(dbInfo);\n            }\n            return db;\n        })\n        .then(db => {\n            // store the latest db reference\n            // in case the db was upgraded\n            dbInfo.db = dbContext.db = db;\n            for (var i = 0; i < forages.length; i++) {\n                forages[i]._dbInfo.db = db;\n            }\n        })\n        .catch(err => {\n            _rejectReadiness(dbInfo, err);\n            throw err;\n        });\n}\n\n// FF doesn't like Promises (micro-tasks) and IDDB store operations,\n// so we have to do it with callbacks\nfunction createTransaction(dbInfo, mode, callback, retries) {\n    if (retries === undefined) {\n        retries = 1;\n    }\n\n    try {\n        var tx = dbInfo.db.transaction(dbInfo.storeName, mode);\n        callback(null, tx);\n    } catch (err) {\n        if (\n            retries > 0 &&\n            (!dbInfo.db ||\n                err.name === 'InvalidStateError' ||\n                err.name === 'NotFoundError')\n        ) {\n            return Promise.resolve()\n                .then(() => {\n                    if (\n                        !dbInfo.db ||\n                        (err.name === 'NotFoundError' &&\n                            !dbInfo.db.objectStoreNames.contains(\n                                dbInfo.storeName\n                            ) &&\n                            dbInfo.version <= dbInfo.db.version)\n                    ) {\n                        // increase the db version, to create the new ObjectStore\n                        if (dbInfo.db) {\n                            dbInfo.version = dbInfo.db.version + 1;\n                        }\n                        // Reopen the database for upgrading.\n                        return _getUpgradedConnection(dbInfo);\n                    }\n                })\n                .then(() => {\n                    return _tryReconnect(dbInfo).then(function() {\n                        createTransaction(dbInfo, mode, callback, retries - 1);\n                    });\n                })\n                .catch(callback);\n        }\n\n        callback(err);\n    }\n}\n\nfunction createDbContext() {\n    return {\n        // Running localForages sharing a database.\n        forages: [],\n        // Shared database.\n        db: null,\n        // Database readiness (promise).\n        dbReady: null,\n        // Deferred operations on the database.\n        deferredOperations: []\n    };\n}\n\n// Open the IndexedDB database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    // Get the current context of the database;\n    var dbContext = dbContexts[dbInfo.name];\n\n    // ...or create a new context.\n    if (!dbContext) {\n        dbContext = createDbContext();\n        // Register the new context in the global container.\n        dbContexts[dbInfo.name] = dbContext;\n    }\n\n    // Register itself as a running localForage in the current context.\n    dbContext.forages.push(self);\n\n    // Replace the default `ready()` function with the specialized one.\n    if (!self._initReady) {\n        self._initReady = self.ready;\n        self.ready = _fullyReady;\n    }\n\n    // Create an array of initialization states of the related localForages.\n    var initPromises = [];\n\n    function ignoreErrors() {\n        // Don't handle errors here,\n        // just makes sure related localForages aren't pending.\n        return Promise.resolve();\n    }\n\n    for (var j = 0; j < dbContext.forages.length; j++) {\n        var forage = dbContext.forages[j];\n        if (forage !== self) {\n            // Don't wait for itself...\n            initPromises.push(forage._initReady().catch(ignoreErrors));\n        }\n    }\n\n    // Take a snapshot of the related localForages.\n    var forages = dbContext.forages.slice(0);\n\n    // Initialize the connection process only when\n    // all the related localForages aren't pending.\n    return Promise.all(initPromises)\n        .then(function() {\n            dbInfo.db = dbContext.db;\n            // Get the connection or open a new one without upgrade.\n            return _getOriginalConnection(dbInfo);\n        })\n        .then(function(db) {\n            dbInfo.db = db;\n            if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {\n                // Reopen the database for upgrading.\n                return _getUpgradedConnection(dbInfo);\n            }\n            return db;\n        })\n        .then(function(db) {\n            dbInfo.db = dbContext.db = db;\n            self._dbInfo = dbInfo;\n            // Share the final connection amongst related localForages.\n            for (var k = 0; k < forages.length; k++) {\n                var forage = forages[k];\n                if (forage !== self) {\n                    // Self is already up-to-date.\n                    forage._dbInfo.db = dbInfo.db;\n                    forage._dbInfo.version = dbInfo.version;\n                }\n            }\n        });\n}\n\nfunction getItem(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise(function(resolve, reject) {\n        self\n            .ready()\n            .then(function() {\n                createTransaction(self._dbInfo, READ_ONLY, function(\n                    err,\n                    transaction\n                ) {\n                    if (err) {\n                        return reject(err);\n                    }\n\n                    try {\n                        var store = transaction.objectStore(\n                            self._dbInfo.storeName\n                        );\n                        var req = store.get(key);\n\n                        req.onsuccess = function() {\n                            var value = req.result;\n                            if (value === undefined) {\n                                value = null;\n                            }\n                            if (_isEncodedBlob(value)) {\n                                value = _decodeBlob(value);\n                            }\n                            resolve(value);\n                        };\n\n                        req.onerror = function() {\n                            reject(req.error);\n                        };\n                    } catch (e) {\n                        reject(e);\n                    }\n                });\n            })\n            .catch(reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items stored in database.\nfunction iterate(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise(function(resolve, reject) {\n        self\n            .ready()\n            .then(function() {\n                createTransaction(self._dbInfo, READ_ONLY, function(\n                    err,\n                    transaction\n                ) {\n                    if (err) {\n                        return reject(err);\n                    }\n\n                    try {\n                        var store = transaction.objectStore(\n                            self._dbInfo.storeName\n                        );\n                        var req = store.openCursor();\n                        var iterationNumber = 1;\n\n                        req.onsuccess = function() {\n                            var cursor = req.result;\n\n                            if (cursor) {\n                                var value = cursor.value;\n                                if (_isEncodedBlob(value)) {\n                                    value = _decodeBlob(value);\n                                }\n                                var result = iterator(\n                                    value,\n                                    cursor.key,\n                                    iterationNumber++\n                                );\n\n                                // when the iterator callback returns any\n                                // (non-`undefined`) value, then we stop\n                                // the iteration immediately\n                                if (result !== void 0) {\n                                    resolve(result);\n                                } else {\n                                    cursor.continue();\n                                }\n                            } else {\n                                resolve();\n                            }\n                        };\n\n                        req.onerror = function() {\n                            reject(req.error);\n                        };\n                    } catch (e) {\n                        reject(e);\n                    }\n                });\n            })\n            .catch(reject);\n    });\n\n    executeCallback(promise, callback);\n\n    return promise;\n}\n\nfunction setItem(originalKey, value, callback) {\n    var self = this;\n\n    key = normalizeKey(originalKey);\n\n    var promise = new Promise(function(resolve, reject) {\n        var dbInfo;\n        self\n            .ready()\n            .then(function() {\n                dbInfo = self._dbInfo;\n                if (toString.call(value) === '[object Blob]') {\n                    return _checkBlobSupport(dbInfo.db).then(function(\n                        blobSupport\n                    ) {\n                        if (blobSupport) {\n                            return value;\n                        }\n                        return _encodeBlob(value);\n                    });\n                }\n                return value;\n            })\n            .then(function(value) {\n                createTransaction(self._dbInfo, READ_WRITE, function(\n                    err,\n                    transaction\n                ) {\n                    if (err) {\n                        return reject(err);\n                    }\n\n                    try {\n                        var store = transaction.objectStore(\n                            self._dbInfo.storeName\n                        );\n\n                        // The reason we don't _save_ null is because IE 10 does\n                        // not support saving the `null` type in IndexedDB. How\n                        // ironic, given the bug below!\n                        // See: https://github.com/mozilla/localForage/issues/161\n                        if (value === null) {\n                            value = undefined;\n                        }\n\n                        var req = store.put(value, key);\n\n                        transaction.oncomplete = function() {\n                            // Cast to undefined so the value passed to\n                            // callback/promise is the same as what one would get out\n                            // of `getItem()` later. This leads to some weirdness\n                            // (setItem('foo', undefined) will return `null`), but\n                            // it's not my fault localStorage is our baseline and that\n                            // it's weird.\n                            if (value === undefined) {\n                                value = null;\n                            }\n\n                            document.body.dispatchEvent(\n                                new CustomEvent('store-item-changed', {\n                                    detail: {\n                                        store: self._dbInfo.storeName,\n                                        key: originalKey\n                                    }\n                                })\n                            );\n\n                            resolve(value);\n                        };\n                        transaction.onabort = transaction.onerror = function() {\n                            var err = req.error\n                                ? req.error\n                                : req.transaction.error;\n                            reject(err);\n                        };\n                    } catch (e) {\n                        reject(e);\n                    }\n                });\n            })\n            .catch(reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction removeItem(originalKey, callback) {\n    var self = this;\n\n    key = normalizeKey(originalKey);\n\n    var promise = new Promise(function(resolve, reject) {\n        self\n            .ready()\n            .then(function() {\n                createTransaction(self._dbInfo, READ_WRITE, function(\n                    err,\n                    transaction\n                ) {\n                    if (err) {\n                        return reject(err);\n                    }\n\n                    try {\n                        var store = transaction.objectStore(\n                            self._dbInfo.storeName\n                        );\n                        // We use a Grunt task to make this safe for IE and some\n                        // versions of Android (including those used by Cordova).\n                        // Normally IE won't like `.delete()` and will insist on\n                        // using `['delete']()`, but we have a build step that\n                        // fixes this for us now.\n                        var req = store.delete(key);\n                        transaction.oncomplete = function() {\n                            document.body.dispatchEvent(\n                                new CustomEvent('store-item-removed', {\n                                    detail: {\n                                        store: self._dbInfo.storeName,\n                                        key: originalKey\n                                    }\n                                })\n                            );\n\n                            resolve();\n                        };\n\n                        transaction.onerror = function() {\n                            reject(req.error);\n                        };\n\n                        // The request will be also be aborted if we've exceeded our storage\n                        // space.\n                        transaction.onabort = function() {\n                            var err = req.error\n                                ? req.error\n                                : req.transaction.error;\n                            reject(err);\n                        };\n                    } catch (e) {\n                        reject(e);\n                    }\n                });\n            })\n            .catch(reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction clear(callback) {\n    var self = this;\n\n    var promise = new Promise(function(resolve, reject) {\n        self\n            .ready()\n            .then(function() {\n                createTransaction(self._dbInfo, READ_WRITE, function(\n                    err,\n                    transaction\n                ) {\n                    if (err) {\n                        return reject(err);\n                    }\n\n                    try {\n                        var store = transaction.objectStore(\n                            self._dbInfo.storeName\n                        );\n                        var req = store.clear();\n\n                        transaction.oncomplete = function() {\n                            document.body.dispatchEvent(\n                                new CustomEvent('store-cleared', {\n                                    detail: { store: self._dbInfo.storeName }\n                                })\n                            );\n\n                            resolve();\n                        };\n\n                        transaction.onabort = transaction.onerror = function() {\n                            var err = req.error\n                                ? req.error\n                                : req.transaction.error;\n                            reject(err);\n                        };\n                    } catch (e) {\n                        reject(e);\n                    }\n                });\n            })\n            .catch(reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction length(callback) {\n    var self = this;\n\n    var promise = new Promise(function(resolve, reject) {\n        self\n            .ready()\n            .then(function() {\n                createTransaction(self._dbInfo, READ_ONLY, function(\n                    err,\n                    transaction\n                ) {\n                    if (err) {\n                        return reject(err);\n                    }\n\n                    try {\n                        var store = transaction.objectStore(\n                            self._dbInfo.storeName\n                        );\n                        var req = store.count();\n\n                        req.onsuccess = function() {\n                            resolve(req.result);\n                        };\n\n                        req.onerror = function() {\n                            reject(req.error);\n                        };\n                    } catch (e) {\n                        reject(e);\n                    }\n                });\n            })\n            .catch(reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction key(n, callback) {\n    var self = this;\n\n    var promise = new Promise(function(resolve, reject) {\n        if (n < 0) {\n            resolve(null);\n\n            return;\n        }\n\n        self\n            .ready()\n            .then(function() {\n                createTransaction(self._dbInfo, READ_ONLY, function(\n                    err,\n                    transaction\n                ) {\n                    if (err) {\n                        return reject(err);\n                    }\n\n                    try {\n                        var store = transaction.objectStore(\n                            self._dbInfo.storeName\n                        );\n                        var advanced = false;\n                        var req = store.openKeyCursor();\n\n                        req.onsuccess = function() {\n                            var cursor = req.result;\n                            if (!cursor) {\n                                // this means there weren't enough keys\n                                resolve(null);\n\n                                return;\n                            }\n\n                            if (n === 0) {\n                                // We have the first key, return it if that's what they\n                                // wanted.\n                                resolve(cursor.key);\n                            } else {\n                                if (!advanced) {\n                                    // Otherwise, ask the cursor to skip ahead n\n                                    // records.\n                                    advanced = true;\n                                    cursor.advance(n);\n                                } else {\n                                    // When we get here, we've got the nth key.\n                                    resolve(cursor.key);\n                                }\n                            }\n                        };\n\n                        req.onerror = function() {\n                            reject(req.error);\n                        };\n                    } catch (e) {\n                        reject(e);\n                    }\n                });\n            })\n            .catch(reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys(callback) {\n    var self = this;\n\n    var promise = new Promise(function(resolve, reject) {\n        self\n            .ready()\n            .then(function() {\n                createTransaction(self._dbInfo, READ_ONLY, function(\n                    err,\n                    transaction\n                ) {\n                    if (err) {\n                        return reject(err);\n                    }\n\n                    try {\n                        var store = transaction.objectStore(\n                            self._dbInfo.storeName\n                        );\n                        var req = store.openKeyCursor();\n                        var keys = [];\n\n                        req.onsuccess = function() {\n                            var cursor = req.result;\n\n                            if (!cursor) {\n                                resolve(keys);\n                                return;\n                            }\n\n                            keys.push(cursor.key);\n                            cursor.continue();\n                        };\n\n                        req.onerror = function() {\n                            reject(req.error);\n                        };\n                    } catch (e) {\n                        reject(e);\n                    }\n                });\n            })\n            .catch(reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction dropInstance(options, callback) {\n    callback = getCallback.apply(this, arguments);\n\n    var currentConfig = this.config();\n    options = (typeof options !== 'function' && options) || {};\n    if (!options.name) {\n        options.name = options.name || currentConfig.name;\n        options.storeName = options.storeName || currentConfig.storeName;\n    }\n\n    var self = this;\n    var promise;\n    if (!options.name) {\n        promise = Promise.reject('Invalid arguments');\n    } else {\n        const isCurrentDb =\n            options.name === currentConfig.name && self._dbInfo.db;\n\n        const dbPromise = isCurrentDb\n            ? Promise.resolve(self._dbInfo.db)\n            : _getOriginalConnection(options).then(db => {\n                  const dbContext = dbContexts[options.name];\n                  const forages = dbContext.forages;\n                  dbContext.db = db;\n                  for (var i = 0; i < forages.length; i++) {\n                      forages[i]._dbInfo.db = db;\n                  }\n                  return db;\n              });\n\n        if (!options.storeName) {\n            promise = dbPromise.then(db => {\n                _deferReadiness(options);\n\n                const dbContext = dbContexts[options.name];\n                const forages = dbContext.forages;\n\n                db.close();\n                for (var i = 0; i < forages.length; i++) {\n                    const forage = forages[i];\n                    forage._dbInfo.db = null;\n                }\n\n                const dropDBPromise = new Promise((resolve, reject) => {\n                    var req = idb.deleteDatabase(options.name);\n\n                    req.onerror = () => {\n                        const db = req.result;\n                        if (db) {\n                            db.close();\n                        }\n                        reject(req.error);\n                    };\n\n                    req.onblocked = () => {\n                        // Closing all open connections in onversionchange handler should prevent this situation, but if\n                        // we do get here, it just means the request remains pending - eventually it will succeed or error\n                        console.warn(\n                            'dropInstance blocked for database \"' +\n                                options.name +\n                                '\" until all open connections are closed'\n                        );\n                    };\n\n                    req.onsuccess = () => {\n                        const db = req.result;\n                        if (db) {\n                            db.close();\n                        }\n                        resolve(db);\n                    };\n                });\n\n                return dropDBPromise\n                    .then(db => {\n                        dbContext.db = db;\n                        for (var i = 0; i < forages.length; i++) {\n                            const forage = forages[i];\n                            _advanceReadiness(forage._dbInfo);\n                        }\n                    })\n                    .catch(err => {\n                        (\n                            _rejectReadiness(options, err) || Promise.resolve()\n                        ).catch(() => {});\n                        throw err;\n                    });\n            });\n        } else {\n            promise = dbPromise.then(db => {\n                if (!db.objectStoreNames.contains(options.storeName)) {\n                    return;\n                }\n\n                const newVersion = db.version + 1;\n\n                _deferReadiness(options);\n\n                const dbContext = dbContexts[options.name];\n                const forages = dbContext.forages;\n\n                db.close();\n                for (let i = 0; i < forages.length; i++) {\n                    const forage = forages[i];\n                    forage._dbInfo.db = null;\n                    forage._dbInfo.version = newVersion;\n                }\n\n                const dropObjectPromise = new Promise((resolve, reject) => {\n                    const req = idb.open(options.name, newVersion);\n\n                    req.onerror = err => {\n                        const db = req.result;\n                        db.close();\n                        reject(err);\n                    };\n\n                    req.onupgradeneeded = () => {\n                        var db = req.result;\n                        db.deleteObjectStore(options.storeName);\n                    };\n\n                    req.onsuccess = () => {\n                        const db = req.result;\n                        db.close();\n                        resolve(db);\n                    };\n                });\n\n                return dropObjectPromise\n                    .then(db => {\n                        dbContext.db = db;\n                        for (let j = 0; j < forages.length; j++) {\n                            const forage = forages[j];\n                            forage._dbInfo.db = db;\n                            _advanceReadiness(forage._dbInfo);\n                        }\n                    })\n                    .catch(err => {\n                        (\n                            _rejectReadiness(options, err) || Promise.resolve()\n                        ).catch(() => {});\n                        throw err;\n                    });\n            });\n        }\n    }\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar asyncStorage = {\n    _driver: 'asyncStorage',\n    _initStorage: _initStorage,\n    _support: isIndexedDBValid(),\n    iterate: iterate,\n    getItem: getItem,\n    setItem: setItem,\n    removeItem: removeItem,\n    clear: clear,\n    length: length,\n    key: key,\n    keys: keys,\n    dropInstance: dropInstance\n};\nexport default asyncStorage;\n","import idb from './idb';\n\nfunction isIndexedDBValid() {\n    try {\n        // Initialize IndexedDB; fall back to vendor-prefixed versions\n        // if needed.\n        if (!idb || !idb.open) {\n            return false;\n        }\n        // We mimic PouchDB here;\n        //\n        // We test for openDatabase because IE Mobile identifies itself\n        // as Safari. Oh the lulz...\n        var isSafari =\n            typeof openDatabase !== 'undefined' &&\n            /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) &&\n            !/Chrome/.test(navigator.userAgent) &&\n            !/BlackBerry/.test(navigator.platform);\n\n        var hasFetch =\n            typeof fetch === 'function' &&\n            fetch.toString().indexOf('[native code') !== -1;\n\n        // Safari <10.1 does not meet our requirements for IDB support\n        // (see: https://github.com/pouchdb/pouchdb/issues/5572).\n        // Safari 10.1 shipped with fetch, we can use that to detect it.\n        // Note: this creates issues with `window.fetch` polyfills and\n        // overrides; see:\n        // https://github.com/localForage/localForage/issues/856\n        return (\n            (!isSafari || hasFetch) &&\n            typeof indexedDB !== 'undefined' &&\n            // some outdated implementations of IDB that appear on Samsung\n            // and HTC Android devices <4.4 are missing IDBKeyRange\n            // See: https://github.com/mozilla/localForage/issues/128\n            // See: https://github.com/mozilla/localForage/issues/272\n            typeof IDBKeyRange !== 'undefined'\n        );\n    } catch (e) {\n        return false;\n    }\n}\n\nexport default isIndexedDBValid;\n","/* eslint-disable no-bitwise */\nimport createBlob from './createBlob';\n\n// Sadly, the best way to save binary data in WebSQL/localStorage is serializing\n// it to Base64, so this is how we store it to prevent very strange errors with less\n// verbose ways of binary <-> string data storage.\nvar BASE_CHARS =\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nvar BLOB_TYPE_PREFIX = '~~local_forage_type~';\nvar BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;\n\nvar SERIALIZED_MARKER = '__lfsc__:';\nvar SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\n\n// OMG the serializations!\nvar TYPE_ARRAYBUFFER = 'arbf';\nvar TYPE_BLOB = 'blob';\nvar TYPE_INT8ARRAY = 'si08';\nvar TYPE_UINT8ARRAY = 'ui08';\nvar TYPE_UINT8CLAMPEDARRAY = 'uic8';\nvar TYPE_INT16ARRAY = 'si16';\nvar TYPE_INT32ARRAY = 'si32';\nvar TYPE_UINT16ARRAY = 'ur16';\nvar TYPE_UINT32ARRAY = 'ui32';\nvar TYPE_FLOAT32ARRAY = 'fl32';\nvar TYPE_FLOAT64ARRAY = 'fl64';\nvar TYPE_SERIALIZED_MARKER_LENGTH =\n    SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\n\nvar toString = Object.prototype.toString;\n\nfunction stringToBuffer(serializedString) {\n    // Fill the string into a ArrayBuffer.\n    var bufferLength = serializedString.length * 0.75;\n    var len = serializedString.length;\n    var i;\n    var p = 0;\n    var encoded1, encoded2, encoded3, encoded4;\n\n    if (serializedString[serializedString.length - 1] === '=') {\n        bufferLength--;\n        if (serializedString[serializedString.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n\n    var buffer = new ArrayBuffer(bufferLength);\n    var bytes = new Uint8Array(buffer);\n\n    for (i = 0; i < len; i += 4) {\n        encoded1 = BASE_CHARS.indexOf(serializedString[i]);\n        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);\n        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);\n        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);\n\n        /*jslint bitwise: true */\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n    return buffer;\n}\n\n// Converts a buffer to a string to store, serialized, in the backend\n// storage library.\nfunction bufferToString(buffer) {\n    // base64-arraybuffer\n    var bytes = new Uint8Array(buffer);\n    var base64String = '';\n    var i;\n\n    for (i = 0; i < bytes.length; i += 3) {\n        /*jslint bitwise: true */\n        base64String += BASE_CHARS[bytes[i] >> 2];\n        base64String += BASE_CHARS[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64String +=\n            BASE_CHARS[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64String += BASE_CHARS[bytes[i + 2] & 63];\n    }\n\n    if (bytes.length % 3 === 2) {\n        base64String = base64String.substring(0, base64String.length - 1) + '=';\n    } else if (bytes.length % 3 === 1) {\n        base64String =\n            base64String.substring(0, base64String.length - 2) + '==';\n    }\n\n    return base64String;\n}\n\n// Serialize a value, afterwards executing a callback (which usually\n// instructs the `setItem()` callback/promise to be executed). This is how\n// we store binary data with localStorage.\nfunction serialize(value, callback) {\n    var valueType = '';\n    if (value) {\n        valueType = toString.call(value);\n    }\n\n    // Cannot use `value instanceof ArrayBuffer` or such here, as these\n    // checks fail when running the tests using casper.js...\n    //\n    // TODO: See why those tests fail and use a better solution.\n    if (\n        value &&\n        (valueType === '[object ArrayBuffer]' ||\n            (value.buffer &&\n                toString.call(value.buffer) === '[object ArrayBuffer]'))\n    ) {\n        // Convert binary arrays to a string and prefix the string with\n        // a special marker.\n        var buffer;\n        var marker = SERIALIZED_MARKER;\n\n        if (value instanceof ArrayBuffer) {\n            buffer = value;\n            marker += TYPE_ARRAYBUFFER;\n        } else {\n            buffer = value.buffer;\n\n            if (valueType === '[object Int8Array]') {\n                marker += TYPE_INT8ARRAY;\n            } else if (valueType === '[object Uint8Array]') {\n                marker += TYPE_UINT8ARRAY;\n            } else if (valueType === '[object Uint8ClampedArray]') {\n                marker += TYPE_UINT8CLAMPEDARRAY;\n            } else if (valueType === '[object Int16Array]') {\n                marker += TYPE_INT16ARRAY;\n            } else if (valueType === '[object Uint16Array]') {\n                marker += TYPE_UINT16ARRAY;\n            } else if (valueType === '[object Int32Array]') {\n                marker += TYPE_INT32ARRAY;\n            } else if (valueType === '[object Uint32Array]') {\n                marker += TYPE_UINT32ARRAY;\n            } else if (valueType === '[object Float32Array]') {\n                marker += TYPE_FLOAT32ARRAY;\n            } else if (valueType === '[object Float64Array]') {\n                marker += TYPE_FLOAT64ARRAY;\n            } else {\n                callback(new Error('Failed to get type for BinaryArray'));\n            }\n        }\n\n        callback(marker + bufferToString(buffer));\n    } else if (valueType === '[object Blob]') {\n        // Conver the blob to a binaryArray and then to a string.\n        var fileReader = new FileReader();\n\n        fileReader.onload = function() {\n            // Backwards-compatible prefix for the blob type.\n            var str =\n                BLOB_TYPE_PREFIX +\n                value.type +\n                '~' +\n                bufferToString(this.result);\n\n            callback(SERIALIZED_MARKER + TYPE_BLOB + str);\n        };\n\n        fileReader.readAsArrayBuffer(value);\n    } else {\n        try {\n            callback(JSON.stringify(value));\n        } catch (e) {\n            console.error(\"Couldn't convert value into a JSON string: \", value);\n\n            callback(null, e);\n        }\n    }\n}\n\n// Deserialize data we've inserted into a value column/field. We place\n// special markers into our strings to mark them as encoded; this isn't\n// as nice as a meta field, but it's the only sane thing we can do whilst\n// keeping localStorage support intact.\n//\n// Oftentimes this will just deserialize JSON content, but if we have a\n// special marker (SERIALIZED_MARKER, defined above), we will extract\n// some kind of arraybuffer/binary data/typed array out of the string.\nfunction deserialize(value) {\n    // If we haven't marked this string as being specially serialized (i.e.\n    // something other than serialized JSON), we can just return it and be\n    // done with it.\n    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\n        return JSON.parse(value);\n    }\n\n    // The following code deals with deserializing some kind of Blob or\n    // TypedArray. First we separate out the type of data we're dealing\n    // with from the data itself.\n    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n    var type = value.substring(\n        SERIALIZED_MARKER_LENGTH,\n        TYPE_SERIALIZED_MARKER_LENGTH\n    );\n\n    var blobType;\n    // Backwards-compatible blob type serialization strategy.\n    // DBs created with older versions of localForage will simply not have the blob type.\n    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {\n        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);\n        blobType = matcher[1];\n        serializedString = serializedString.substring(matcher[0].length);\n    }\n    var buffer = stringToBuffer(serializedString);\n\n    // Return the right type based on the code/type set during\n    // serialization.\n    switch (type) {\n        case TYPE_ARRAYBUFFER:\n            return buffer;\n        case TYPE_BLOB:\n            return createBlob([buffer], { type: blobType });\n        case TYPE_INT8ARRAY:\n            return new Int8Array(buffer);\n        case TYPE_UINT8ARRAY:\n            return new Uint8Array(buffer);\n        case TYPE_UINT8CLAMPEDARRAY:\n            return new Uint8ClampedArray(buffer);\n        case TYPE_INT16ARRAY:\n            return new Int16Array(buffer);\n        case TYPE_UINT16ARRAY:\n            return new Uint16Array(buffer);\n        case TYPE_INT32ARRAY:\n            return new Int32Array(buffer);\n        case TYPE_UINT32ARRAY:\n            return new Uint32Array(buffer);\n        case TYPE_FLOAT32ARRAY:\n            return new Float32Array(buffer);\n        case TYPE_FLOAT64ARRAY:\n            return new Float64Array(buffer);\n        default:\n            throw new Error('Unkown type: ' + type);\n    }\n}\n\nvar localforageSerializer = {\n    serialize: serialize,\n    deserialize: deserialize,\n    stringToBuffer: stringToBuffer,\n    bufferToString: bufferToString\n};\n\nexport default localforageSerializer;\n","import isWebSQLValid from '../utils/isWebSQLValid';\nimport serializer from '../utils/serializer';\nimport Promise from '../utils/promise';\nimport executeCallback from '../utils/executeCallback';\nimport normalizeKey from '../utils/normalizeKey';\nimport getCallback from '../utils/getCallback';\n\n/*\n * Includes code from:\n *\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n\nfunction createDbTable(t, dbInfo, callback, errorCallback) {\n    t.executeSql(\n        `CREATE TABLE IF NOT EXISTS ${dbInfo.storeName} ` +\n            '(id INTEGER PRIMARY KEY, key unique, value)',\n        [],\n        callback,\n        errorCallback\n    );\n}\n\n// Open the WebSQL database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] =\n                typeof options[i] !== 'string'\n                    ? options[i].toString()\n                    : options[i];\n        }\n    }\n\n    var dbInfoPromise = new Promise(function(resolve, reject) {\n        // Open the database; the openDatabase API will automatically\n        // create it for us if it doesn't exist.\n        try {\n            dbInfo.db = openDatabase(\n                dbInfo.name,\n                String(dbInfo.version),\n                dbInfo.description,\n                dbInfo.size\n            );\n        } catch (e) {\n            return reject(e);\n        }\n\n        // Create our key/value table if it doesn't exist.\n        dbInfo.db.transaction(function(t) {\n            createDbTable(\n                t,\n                dbInfo,\n                function() {\n                    self._dbInfo = dbInfo;\n                    resolve();\n                },\n                function(t, error) {\n                    reject(error);\n                }\n            );\n        }, reject);\n    });\n\n    dbInfo.serializer = serializer;\n    return dbInfoPromise;\n}\n\nfunction tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {\n    t.executeSql(\n        sqlStatement,\n        args,\n        callback,\n        function(t, error) {\n            if (error.code === error.SYNTAX_ERR) {\n                t.executeSql(\n                    'SELECT name FROM sqlite_master ' +\n                        \"WHERE type='table' AND name = ?\",\n                    [dbInfo.storeName],\n                    function(t, results) {\n                        if (!results.rows.length) {\n                            // if the table is missing (was deleted)\n                            // re-create it table and retry\n                            createDbTable(\n                                t,\n                                dbInfo,\n                                function() {\n                                    t.executeSql(\n                                        sqlStatement,\n                                        args,\n                                        callback,\n                                        errorCallback\n                                    );\n                                },\n                                errorCallback\n                            );\n                        } else {\n                            errorCallback(t, error);\n                        }\n                    },\n                    errorCallback\n                );\n            } else {\n                errorCallback(t, error);\n            }\n        },\n        errorCallback\n    );\n}\n\nfunction getItem(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise(function(resolve, reject) {\n        self\n            .ready()\n            .then(function() {\n                var dbInfo = self._dbInfo;\n                dbInfo.db.transaction(function(t) {\n                    tryExecuteSql(\n                        t,\n                        dbInfo,\n                        `SELECT * FROM ${\n                            dbInfo.storeName\n                        } WHERE key = ? LIMIT 1`,\n                        [key],\n                        function(t, results) {\n                            var result = results.rows.length\n                                ? results.rows.item(0).value\n                                : null;\n\n                            // Check to see if this is serialized content we need to\n                            // unpack.\n                            if (result) {\n                                result = dbInfo.serializer.deserialize(result);\n                            }\n\n                            resolve(result);\n                        },\n                        function(t, error) {\n                            reject(error);\n                        }\n                    );\n                });\n            })\n            .catch(reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction iterate(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise(function(resolve, reject) {\n        self\n            .ready()\n            .then(function() {\n                var dbInfo = self._dbInfo;\n\n                dbInfo.db.transaction(function(t) {\n                    tryExecuteSql(\n                        t,\n                        dbInfo,\n                        `SELECT * FROM ${dbInfo.storeName}`,\n                        [],\n                        function(t, results) {\n                            var rows = results.rows;\n                            var length = rows.length;\n\n                            for (var i = 0; i < length; i++) {\n                                var item = rows.item(i);\n                                var result = item.value;\n\n                                // Check to see if this is serialized content\n                                // we need to unpack.\n                                if (result) {\n                                    result = dbInfo.serializer.deserialize(\n                                        result\n                                    );\n                                }\n\n                                result = iterator(result, item.key, i + 1);\n\n                                // void(0) prevents problems with redefinition\n                                // of `undefined`.\n                                if (result !== void 0) {\n                                    resolve(result);\n                                    return;\n                                }\n                            }\n\n                            resolve();\n                        },\n                        function(t, error) {\n                            reject(error);\n                        }\n                    );\n                });\n            })\n            .catch(reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction _setItem(key, value, callback, retriesLeft) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise(function(resolve, reject) {\n        self\n            .ready()\n            .then(function() {\n                // The localStorage API doesn't return undefined values in an\n                // \"expected\" way, so undefined is always cast to null in all\n                // drivers. See: https://github.com/mozilla/localForage/pull/42\n                if (value === undefined) {\n                    value = null;\n                }\n\n                // Save the original value to pass to the callback.\n                var originalValue = value;\n\n                var dbInfo = self._dbInfo;\n                dbInfo.serializer.serialize(value, function(value, error) {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        dbInfo.db.transaction(\n                            function(t) {\n                                tryExecuteSql(\n                                    t,\n                                    dbInfo,\n                                    `INSERT OR REPLACE INTO ${\n                                        dbInfo.storeName\n                                    } ` + '(key, value) VALUES (?, ?)',\n                                    [key, value],\n                                    function() {\n                                        resolve(originalValue);\n                                    },\n                                    function(t, error) {\n                                        reject(error);\n                                    }\n                                );\n                            },\n                            function(sqlError) {\n                                // The transaction failed; check\n                                // to see if it's a quota error.\n                                if (sqlError.code === sqlError.QUOTA_ERR) {\n                                    // We reject the callback outright for now, but\n                                    // it's worth trying to re-run the transaction.\n                                    // Even if the user accepts the prompt to use\n                                    // more storage on Safari, this error will\n                                    // be called.\n                                    //\n                                    // Try to re-run the transaction.\n                                    if (retriesLeft > 0) {\n                                        resolve(\n                                            _setItem.apply(self, [\n                                                key,\n                                                originalValue,\n                                                callback,\n                                                retriesLeft - 1\n                                            ])\n                                        );\n                                        return;\n                                    }\n                                    reject(sqlError);\n                                }\n                            }\n                        );\n                    }\n                });\n            })\n            .catch(reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction setItem(key, value, callback) {\n    return _setItem.apply(this, [key, value, callback, 1]);\n}\n\nfunction removeItem(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise(function(resolve, reject) {\n        self\n            .ready()\n            .then(function() {\n                var dbInfo = self._dbInfo;\n                dbInfo.db.transaction(function(t) {\n                    tryExecuteSql(\n                        t,\n                        dbInfo,\n                        `DELETE FROM ${dbInfo.storeName} WHERE key = ?`,\n                        [key],\n                        function() {\n                            resolve();\n                        },\n                        function(t, error) {\n                            reject(error);\n                        }\n                    );\n                });\n            })\n            .catch(reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Deletes every item in the table.\n// TODO: Find out if this resets the AUTO_INCREMENT number.\nfunction clear(callback) {\n    var self = this;\n\n    var promise = new Promise(function(resolve, reject) {\n        self\n            .ready()\n            .then(function() {\n                var dbInfo = self._dbInfo;\n                dbInfo.db.transaction(function(t) {\n                    tryExecuteSql(\n                        t,\n                        dbInfo,\n                        `DELETE FROM ${dbInfo.storeName}`,\n                        [],\n                        function() {\n                            resolve();\n                        },\n                        function(t, error) {\n                            reject(error);\n                        }\n                    );\n                });\n            })\n            .catch(reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Does a simple `COUNT(key)` to get the number of items stored in\n// localForage.\nfunction length(callback) {\n    var self = this;\n\n    var promise = new Promise(function(resolve, reject) {\n        self\n            .ready()\n            .then(function() {\n                var dbInfo = self._dbInfo;\n                dbInfo.db.transaction(function(t) {\n                    // Ahhh, SQL makes this one soooooo easy.\n                    tryExecuteSql(\n                        t,\n                        dbInfo,\n                        `SELECT COUNT(key) as c FROM ${dbInfo.storeName}`,\n                        [],\n                        function(t, results) {\n                            var result = results.rows.item(0).c;\n                            resolve(result);\n                        },\n                        function(t, error) {\n                            reject(error);\n                        }\n                    );\n                });\n            })\n            .catch(reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Return the key located at key index X; essentially gets the key from a\n// `WHERE id = ?`. This is the most efficient way I can think to implement\n// this rarely-used (in my experience) part of the API, but it can seem\n// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n// the ID of each key will change every time it's updated. Perhaps a stored\n// procedure for the `setItem()` SQL would solve this problem?\n// TODO: Don't change ID on `setItem()`.\nfunction key(n, callback) {\n    var self = this;\n\n    var promise = new Promise(function(resolve, reject) {\n        self\n            .ready()\n            .then(function() {\n                var dbInfo = self._dbInfo;\n                dbInfo.db.transaction(function(t) {\n                    tryExecuteSql(\n                        t,\n                        dbInfo,\n                        `SELECT key FROM ${\n                            dbInfo.storeName\n                        } WHERE id = ? LIMIT 1`,\n                        [n + 1],\n                        function(t, results) {\n                            var result = results.rows.length\n                                ? results.rows.item(0).key\n                                : null;\n                            resolve(result);\n                        },\n                        function(t, error) {\n                            reject(error);\n                        }\n                    );\n                });\n            })\n            .catch(reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys(callback) {\n    var self = this;\n\n    var promise = new Promise(function(resolve, reject) {\n        self\n            .ready()\n            .then(function() {\n                var dbInfo = self._dbInfo;\n                dbInfo.db.transaction(function(t) {\n                    tryExecuteSql(\n                        t,\n                        dbInfo,\n                        `SELECT key FROM ${dbInfo.storeName}`,\n                        [],\n                        function(t, results) {\n                            var keys = [];\n\n                            for (var i = 0; i < results.rows.length; i++) {\n                                keys.push(results.rows.item(i).key);\n                            }\n\n                            resolve(keys);\n                        },\n                        function(t, error) {\n                            reject(error);\n                        }\n                    );\n                });\n            })\n            .catch(reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// https://www.w3.org/TR/webdatabase/#databases\n// > There is no way to enumerate or delete the databases available for an origin from this API.\nfunction getAllStoreNames(db) {\n    return new Promise(function(resolve, reject) {\n        db.transaction(\n            function(t) {\n                t.executeSql(\n                    'SELECT name FROM sqlite_master ' +\n                        \"WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'\",\n                    [],\n                    function(t, results) {\n                        var storeNames = [];\n\n                        for (var i = 0; i < results.rows.length; i++) {\n                            storeNames.push(results.rows.item(i).name);\n                        }\n\n                        resolve({\n                            db,\n                            storeNames\n                        });\n                    },\n                    function(t, error) {\n                        reject(error);\n                    }\n                );\n            },\n            function(sqlError) {\n                reject(sqlError);\n            }\n        );\n    });\n}\n\nfunction dropInstance(options, callback) {\n    callback = getCallback.apply(this, arguments);\n\n    var currentConfig = this.config();\n    options = (typeof options !== 'function' && options) || {};\n    if (!options.name) {\n        options.name = options.name || currentConfig.name;\n        options.storeName = options.storeName || currentConfig.storeName;\n    }\n\n    var self = this;\n    var promise;\n    if (!options.name) {\n        promise = Promise.reject('Invalid arguments');\n    } else {\n        promise = new Promise(function(resolve) {\n            var db;\n            if (options.name === currentConfig.name) {\n                // use the db reference of the current instance\n                db = self._dbInfo.db;\n            } else {\n                db = openDatabase(options.name, '', '', 0);\n            }\n\n            if (!options.storeName) {\n                // drop all database tables\n                resolve(getAllStoreNames(db));\n            } else {\n                resolve({\n                    db,\n                    storeNames: [options.storeName]\n                });\n            }\n        }).then(function(operationInfo) {\n            return new Promise(function(resolve, reject) {\n                operationInfo.db.transaction(\n                    function(t) {\n                        function dropTable(storeName) {\n                            return new Promise(function(resolve, reject) {\n                                t.executeSql(\n                                    `DROP TABLE IF EXISTS ${storeName}`,\n                                    [],\n                                    function() {\n                                        resolve();\n                                    },\n                                    function(t, error) {\n                                        reject(error);\n                                    }\n                                );\n                            });\n                        }\n\n                        var operations = [];\n                        for (\n                            var i = 0, len = operationInfo.storeNames.length;\n                            i < len;\n                            i++\n                        ) {\n                            operations.push(\n                                dropTable(operationInfo.storeNames[i])\n                            );\n                        }\n\n                        Promise.all(operations)\n                            .then(function() {\n                                resolve();\n                            })\n                            .catch(function(e) {\n                                reject(e);\n                            });\n                    },\n                    function(sqlError) {\n                        reject(sqlError);\n                    }\n                );\n            });\n        });\n    }\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar webSQLStorage = {\n    _driver: 'webSQLStorage',\n    _initStorage: _initStorage,\n    _support: isWebSQLValid(),\n    iterate: iterate,\n    getItem: getItem,\n    setItem: setItem,\n    removeItem: removeItem,\n    clear: clear,\n    length: length,\n    key: key,\n    keys: keys,\n    dropInstance: dropInstance\n};\n\nexport default webSQLStorage;\n","function isWebSQLValid() {\n    return typeof openDatabase === 'function';\n}\n\nexport default isWebSQLValid;\n","// If IndexedDB isn't available, we'll fall back to localStorage.\n// Note that this will have considerable performance and storage\n// side-effects (all data will be serialized on save and only data that\n// can be converted to a string via `JSON.stringify()` will be saved).\n\nimport isLocalStorageValid from '../utils/isLocalStorageValid';\nimport serializer from '../utils/serializer';\nimport Promise from '../utils/promise';\nimport executeCallback from '../utils/executeCallback';\nimport normalizeKey from '../utils/normalizeKey';\nimport getCallback from '../utils/getCallback';\n\nfunction _getKeyPrefix(options, defaultConfig) {\n    var keyPrefix = options.name + '/';\n\n    if (options.storeName !== defaultConfig.storeName) {\n        keyPrefix += options.storeName + '/';\n    }\n    return keyPrefix;\n}\n\n// Check if localStorage throws when saving an item\nfunction checkIfLocalStorageThrows() {\n    var localStorageTestKey = '_localforage_support_test';\n\n    try {\n        localStorage.setItem(localStorageTestKey, true);\n        localStorage.removeItem(localStorageTestKey);\n\n        return false;\n    } catch (e) {\n        return true;\n    }\n}\n\n// Check if localStorage is usable and allows to save an item\n// This method checks if localStorage is usable in Safari Private Browsing\n// mode, or in any other case where the available quota for localStorage\n// is 0 and there wasn't any saved items yet.\nfunction _isLocalStorageUsable() {\n    return !checkIfLocalStorageThrows() || localStorage.length > 0;\n}\n\n// Config the localStorage backend, using options set in the config.\nfunction _initStorage(options) {\n    var self = this;\n    var dbInfo = {};\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    dbInfo.keyPrefix = _getKeyPrefix(options, self._defaultConfig);\n\n    if (!_isLocalStorageUsable()) {\n        return Promise.reject();\n    }\n\n    self._dbInfo = dbInfo;\n    dbInfo.serializer = serializer;\n\n    return Promise.resolve();\n}\n\n// Remove all keys from the datastore, effectively destroying all data in\n// the app's key/value store!\nfunction clear(callback) {\n    var self = this;\n    var promise = self.ready().then(function() {\n        var keyPrefix = self._dbInfo.keyPrefix;\n\n        for (var i = localStorage.length - 1; i >= 0; i--) {\n            var key = localStorage.key(i);\n\n            if (key.indexOf(keyPrefix) === 0) {\n                localStorage.removeItem(key);\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Retrieve an item from the store. Unlike the original async_storage\n// library in Gaia, we don't modify return values at all. If a key's value\n// is `undefined`, we pass that value to the callback function.\nfunction getItem(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = self.ready().then(function() {\n        var dbInfo = self._dbInfo;\n        var result = localStorage.getItem(dbInfo.keyPrefix + key);\n\n        // If a result was found, parse it from the serialized\n        // string into a JS object. If result isn't truthy, the key\n        // is likely undefined and we'll pass it straight to the\n        // callback.\n        if (result) {\n            result = dbInfo.serializer.deserialize(result);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items in the store.\nfunction iterate(iterator, callback) {\n    var self = this;\n\n    var promise = self.ready().then(function() {\n        var dbInfo = self._dbInfo;\n        var keyPrefix = dbInfo.keyPrefix;\n        var keyPrefixLength = keyPrefix.length;\n        var length = localStorage.length;\n\n        // We use a dedicated iterator instead of the `i` variable below\n        // so other keys we fetch in localStorage aren't counted in\n        // the `iterationNumber` argument passed to the `iterate()`\n        // callback.\n        //\n        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\n        var iterationNumber = 1;\n\n        for (var i = 0; i < length; i++) {\n            var key = localStorage.key(i);\n            if (key.indexOf(keyPrefix) !== 0) {\n                continue;\n            }\n            var value = localStorage.getItem(key);\n\n            // If a result was found, parse it from the serialized\n            // string into a JS object. If result isn't truthy, the\n            // key is likely undefined and we'll pass it straight\n            // to the iterator.\n            if (value) {\n                value = dbInfo.serializer.deserialize(value);\n            }\n\n            value = iterator(\n                value,\n                key.substring(keyPrefixLength),\n                iterationNumber++\n            );\n\n            if (value !== void 0) {\n                return value;\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Same as localStorage's key() method, except takes a callback.\nfunction key(n, callback) {\n    var self = this;\n    var promise = self.ready().then(function() {\n        var dbInfo = self._dbInfo;\n        var result;\n        try {\n            result = localStorage.key(n);\n        } catch (error) {\n            result = null;\n        }\n\n        // Remove the prefix from the key, if a key is found.\n        if (result) {\n            result = result.substring(dbInfo.keyPrefix.length);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys(callback) {\n    var self = this;\n    var promise = self.ready().then(function() {\n        var dbInfo = self._dbInfo;\n        var length = localStorage.length;\n        var keys = [];\n\n        for (var i = 0; i < length; i++) {\n            var itemKey = localStorage.key(i);\n            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {\n                keys.push(itemKey.substring(dbInfo.keyPrefix.length));\n            }\n        }\n\n        return keys;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Supply the number of keys in the datastore to the callback function.\nfunction length(callback) {\n    var self = this;\n    var promise = self.keys().then(function(keys) {\n        return keys.length;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Remove an item from the store, nice and simple.\nfunction removeItem(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = self.ready().then(function() {\n        var dbInfo = self._dbInfo;\n        localStorage.removeItem(dbInfo.keyPrefix + key);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Set a key's value and run an optional callback once the value is set.\n// Unlike Gaia's implementation, the callback function is passed the value,\n// in case you want to operate on that value only after you're sure it\n// saved, or something like that.\nfunction setItem(key, value, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = self.ready().then(function() {\n        // Convert undefined values to null.\n        // https://github.com/mozilla/localForage/pull/42\n        if (value === undefined) {\n            value = null;\n        }\n\n        // Save the original value to pass to the callback.\n        var originalValue = value;\n\n        return new Promise(function(resolve, reject) {\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function(value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    try {\n                        localStorage.setItem(dbInfo.keyPrefix + key, value);\n                        resolve(originalValue);\n                    } catch (e) {\n                        // localStorage capacity exceeded.\n                        // TODO: Make this a specific error/event.\n                        if (\n                            e.name === 'QuotaExceededError' ||\n                            e.name === 'NS_ERROR_DOM_QUOTA_REACHED'\n                        ) {\n                            reject(e);\n                        }\n                        reject(e);\n                    }\n                }\n            });\n        });\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction dropInstance(options, callback) {\n    callback = getCallback.apply(this, arguments);\n\n    options = (typeof options !== 'function' && options) || {};\n    if (!options.name) {\n        var currentConfig = this.config();\n        options.name = options.name || currentConfig.name;\n        options.storeName = options.storeName || currentConfig.storeName;\n    }\n\n    var self = this;\n    var promise;\n    if (!options.name) {\n        promise = Promise.reject('Invalid arguments');\n    } else {\n        promise = new Promise(function(resolve) {\n            if (!options.storeName) {\n                resolve(`${options.name}/`);\n            } else {\n                resolve(_getKeyPrefix(options, self._defaultConfig));\n            }\n        }).then(function(keyPrefix) {\n            for (var i = localStorage.length - 1; i >= 0; i--) {\n                var key = localStorage.key(i);\n\n                if (key.indexOf(keyPrefix) === 0) {\n                    localStorage.removeItem(key);\n                }\n            }\n        });\n    }\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar localStorageWrapper = {\n    _driver: 'localStorageWrapper',\n    _initStorage: _initStorage,\n    _support: isLocalStorageValid(),\n    iterate: iterate,\n    getItem: getItem,\n    setItem: setItem,\n    removeItem: removeItem,\n    clear: clear,\n    length: length,\n    key: key,\n    keys: keys,\n    dropInstance: dropInstance\n};\n\nexport default localStorageWrapper;\n","function isLocalStorageValid() {\n    try {\n        return (\n            typeof localStorage !== 'undefined' &&\n            'setItem' in localStorage &&\n            // in IE8 typeof localStorage.setItem === 'object'\n            !!localStorage.setItem\n        );\n    } catch (e) {\n        return false;\n    }\n}\n\nexport default isLocalStorageValid;\n","const sameValue = (x, y) =>\n    x === y ||\n    (typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y));\n\nconst includes = (array, searchElement) => {\n    const len = array.length;\n    let i = 0;\n    while (i < len) {\n        if (sameValue(array[i], searchElement)) {\n            return true;\n        }\n        i++;\n    }\n\n    return false;\n};\n\nexport default includes;\n","const isArray =\n    Array.isArray ||\n    function(arg) {\n        return Object.prototype.toString.call(arg) === '[object Array]';\n    };\n\nexport default isArray;\n","import idbDriver from './drivers/indexeddb';\nimport websqlDriver from './drivers/websql';\nimport localstorageDriver from './drivers/localstorage';\nimport serializer from './utils/serializer';\nimport Promise from './utils/promise';\nimport executeCallback from './utils/executeCallback';\nimport executeTwoCallbacks from './utils/executeTwoCallbacks';\nimport includes from './utils/includes';\nimport isArray from './utils/isArray';\n\n// Drivers are stored here when `defineDriver()` is called.\n// They are shared across all instances of localForage.\nconst DefinedDrivers = {};\n\nconst DriverSupport = {};\n\nconst DefaultDrivers = {\n    INDEXEDDB: idbDriver,\n    WEBSQL: websqlDriver,\n    LOCALSTORAGE: localstorageDriver\n};\n\nconst DefaultDriverOrder = [\n    DefaultDrivers.INDEXEDDB._driver,\n    DefaultDrivers.WEBSQL._driver,\n    DefaultDrivers.LOCALSTORAGE._driver\n];\n\nconst OptionalDriverMethods = ['dropInstance'];\n\nconst LibraryMethods = [\n    'clear',\n    'getItem',\n    'iterate',\n    'key',\n    'keys',\n    'length',\n    'removeItem',\n    'setItem'\n].concat(OptionalDriverMethods);\n\nconst DefaultConfig = {\n    description: '',\n    driver: DefaultDriverOrder.slice(),\n    name: 'localforage',\n    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size\n    // we can use without a prompt.\n    size: 4980736,\n    storeName: 'keyvaluepairs',\n    version: 1.0\n};\n\nfunction callWhenReady(localForageInstance, libraryMethod) {\n    localForageInstance[libraryMethod] = function() {\n        const _args = arguments;\n        return localForageInstance.ready().then(function() {\n            return localForageInstance[libraryMethod].apply(\n                localForageInstance,\n                _args\n            );\n        });\n    };\n}\n\nfunction extend() {\n    for (let i = 1; i < arguments.length; i++) {\n        const arg = arguments[i];\n\n        if (arg) {\n            for (let key in arg) {\n                if (arg.hasOwnProperty(key)) {\n                    if (isArray(arg[key])) {\n                        arguments[0][key] = arg[key].slice();\n                    } else {\n                        arguments[0][key] = arg[key];\n                    }\n                }\n            }\n        }\n    }\n\n    return arguments[0];\n}\n\nclass LocalForage {\n    constructor(options) {\n        for (let driverTypeKey in DefaultDrivers) {\n            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {\n                const driver = DefaultDrivers[driverTypeKey];\n                const driverName = driver._driver;\n                this[driverTypeKey] = driverName;\n\n                if (!DefinedDrivers[driverName]) {\n                    // we don't need to wait for the promise,\n                    // since the default drivers can be defined\n                    // in a blocking manner\n                    this.defineDriver(driver);\n                }\n            }\n        }\n\n        this._defaultConfig = extend({}, DefaultConfig);\n        this._config = extend({}, this._defaultConfig, options);\n        this._driverSet = null;\n        this._initDriver = null;\n        this._ready = false;\n        this._dbInfo = null;\n\n        this._wrapLibraryMethodsWithReady();\n        this.setDriver(this._config.driver).catch(() => {});\n    }\n\n    // Set any config values for localForage; can be called anytime before\n    // the first API call (e.g. `getItem`, `setItem`).\n    // We loop through options so we don't overwrite existing config\n    // values.\n    config(options) {\n        // If the options argument is an object, we use it to set values.\n        // Otherwise, we return either a specified config value or all\n        // config values.\n        if (typeof options === 'object') {\n            // If localforage is ready and fully initialized, we can't set\n            // any new configuration values. Instead, we return an error.\n            if (this._ready) {\n                return new Error(\n                    \"Can't call config() after localforage \" + 'has been used.'\n                );\n            }\n\n            for (let i in options) {\n                if (i === 'storeName') {\n                    options[i] = options[i].replace(/\\W/g, '_');\n                }\n\n                if (i === 'version' && typeof options[i] !== 'number') {\n                    return new Error('Database version must be a number.');\n                }\n\n                this._config[i] = options[i];\n            }\n\n            // after all config options are set and\n            // the driver option is used, try setting it\n            if ('driver' in options && options.driver) {\n                return this.setDriver(this._config.driver);\n            }\n\n            return true;\n        } else if (typeof options === 'string') {\n            return this._config[options];\n        } else {\n            return this._config;\n        }\n    }\n\n    // Used to define a custom driver, shared across all instances of\n    // localForage.\n    defineDriver(driverObject, callback, errorCallback) {\n        const promise = new Promise(function(resolve, reject) {\n            try {\n                const driverName = driverObject._driver;\n                const complianceError = new Error(\n                    'Custom driver not compliant; see ' +\n                        'https://mozilla.github.io/localForage/#definedriver'\n                );\n\n                // A driver name should be defined and not overlap with the\n                // library-defined, default drivers.\n                if (!driverObject._driver) {\n                    reject(complianceError);\n                    return;\n                }\n\n                const driverMethods = LibraryMethods.concat('_initStorage');\n                for (let i = 0, len = driverMethods.length; i < len; i++) {\n                    const driverMethodName = driverMethods[i];\n\n                    // when the property is there,\n                    // it should be a method even when optional\n                    const isRequired = !includes(\n                        OptionalDriverMethods,\n                        driverMethodName\n                    );\n                    if (\n                        (isRequired || driverObject[driverMethodName]) &&\n                        typeof driverObject[driverMethodName] !== 'function'\n                    ) {\n                        reject(complianceError);\n                        return;\n                    }\n                }\n\n                const configureMissingMethods = function() {\n                    const methodNotImplementedFactory = function(methodName) {\n                        return function() {\n                            const error = new Error(\n                                `Method ${methodName} is not implemented by the current driver`\n                            );\n                            const promise = Promise.reject(error);\n                            executeCallback(\n                                promise,\n                                arguments[arguments.length - 1]\n                            );\n                            return promise;\n                        };\n                    };\n\n                    for (\n                        let i = 0, len = OptionalDriverMethods.length;\n                        i < len;\n                        i++\n                    ) {\n                        const optionalDriverMethod = OptionalDriverMethods[i];\n                        if (!driverObject[optionalDriverMethod]) {\n                            driverObject[\n                                optionalDriverMethod\n                            ] = methodNotImplementedFactory(\n                                optionalDriverMethod\n                            );\n                        }\n                    }\n                };\n\n                configureMissingMethods();\n\n                const setDriverSupport = function(support) {\n                    if (DefinedDrivers[driverName]) {\n                        console.info(\n                            `Redefining LocalForage driver: ${driverName}`\n                        );\n                    }\n                    DefinedDrivers[driverName] = driverObject;\n                    DriverSupport[driverName] = support;\n                    // don't use a then, so that we can define\n                    // drivers that have simple _support methods\n                    // in a blocking manner\n                    resolve();\n                };\n\n                if ('_support' in driverObject) {\n                    if (\n                        driverObject._support &&\n                        typeof driverObject._support === 'function'\n                    ) {\n                        driverObject._support().then(setDriverSupport, reject);\n                    } else {\n                        setDriverSupport(!!driverObject._support);\n                    }\n                } else {\n                    setDriverSupport(true);\n                }\n            } catch (e) {\n                reject(e);\n            }\n        });\n\n        executeTwoCallbacks(promise, callback, errorCallback);\n        return promise;\n    }\n\n    driver() {\n        return this._driver || null;\n    }\n\n    getDriver(driverName, callback, errorCallback) {\n        const getDriverPromise = DefinedDrivers[driverName]\n            ? Promise.resolve(DefinedDrivers[driverName])\n            : Promise.reject(new Error('Driver not found.'));\n\n        executeTwoCallbacks(getDriverPromise, callback, errorCallback);\n        return getDriverPromise;\n    }\n\n    getSerializer(callback) {\n        const serializerPromise = Promise.resolve(serializer);\n        executeTwoCallbacks(serializerPromise, callback);\n        return serializerPromise;\n    }\n\n    ready(callback) {\n        const self = this;\n\n        const promise = self._driverSet.then(() => {\n            if (self._ready === null) {\n                self._ready = self._initDriver();\n            }\n\n            return self._ready;\n        });\n\n        executeTwoCallbacks(promise, callback, callback);\n        return promise;\n    }\n\n    setDriver(drivers, callback, errorCallback) {\n        const self = this;\n\n        if (!isArray(drivers)) {\n            drivers = [drivers];\n        }\n\n        const supportedDrivers = this._getSupportedDrivers(drivers);\n\n        function setDriverToConfig() {\n            self._config.driver = self.driver();\n        }\n\n        function extendSelfWithDriver(driver) {\n            self._extend(driver);\n            setDriverToConfig();\n\n            self._ready = self._initStorage(self._config);\n            return self._ready;\n        }\n\n        function initDriver(supportedDrivers) {\n            return function() {\n                let currentDriverIndex = 0;\n\n                function driverPromiseLoop() {\n                    while (currentDriverIndex < supportedDrivers.length) {\n                        let driverName = supportedDrivers[currentDriverIndex];\n                        currentDriverIndex++;\n\n                        self._dbInfo = null;\n                        self._ready = null;\n\n                        return self\n                            .getDriver(driverName)\n                            .then(extendSelfWithDriver)\n                            .catch(driverPromiseLoop);\n                    }\n\n                    setDriverToConfig();\n                    const error = new Error(\n                        'No available storage method found.'\n                    );\n                    self._driverSet = Promise.reject(error);\n                    return self._driverSet;\n                }\n\n                return driverPromiseLoop();\n            };\n        }\n\n        // There might be a driver initialization in progress\n        // so wait for it to finish in order to avoid a possible\n        // race condition to set _dbInfo\n        const oldDriverSetDone =\n            this._driverSet !== null\n                ? this._driverSet.catch(() => Promise.resolve())\n                : Promise.resolve();\n\n        this._driverSet = oldDriverSetDone\n            .then(() => {\n                const driverName = supportedDrivers[0];\n                self._dbInfo = null;\n                self._ready = null;\n\n                return self.getDriver(driverName).then(driver => {\n                    self._driver = driver._driver;\n                    setDriverToConfig();\n                    self._wrapLibraryMethodsWithReady();\n                    self._initDriver = initDriver(supportedDrivers);\n                });\n            })\n            .catch(() => {\n                setDriverToConfig();\n                const error = new Error('No available storage method found.');\n                self._driverSet = Promise.reject(error);\n                return self._driverSet;\n            });\n\n        executeTwoCallbacks(this._driverSet, callback, errorCallback);\n        return this._driverSet;\n    }\n\n    supports(driverName) {\n        return !!DriverSupport[driverName];\n    }\n\n    _extend(libraryMethodsAndProperties) {\n        extend(this, libraryMethodsAndProperties);\n    }\n\n    _getSupportedDrivers(drivers) {\n        const supportedDrivers = [];\n        for (let i = 0, len = drivers.length; i < len; i++) {\n            const driverName = drivers[i];\n            if (this.supports(driverName)) {\n                supportedDrivers.push(driverName);\n            }\n        }\n        return supportedDrivers;\n    }\n\n    _wrapLibraryMethodsWithReady() {\n        // Add a stub for each driver API method that delays the call to the\n        // corresponding driver method until localForage is ready. These stubs\n        // will be replaced by the driver methods as soon as the driver is\n        // loaded, so there is no performance impact.\n        for (let i = 0, len = LibraryMethods.length; i < len; i++) {\n            callWhenReady(this, LibraryMethods[i]);\n        }\n    }\n\n    createInstance(options) {\n        return new LocalForage(options);\n    }\n}\n\n// The actual localForage object that we expose as a module or via a\n// global. It's extended by pulling in one of our other libraries.\nexport default new LocalForage();\n"],"names":["idb","indexedDB","webkitIndexedDB","mozIndexedDB","OIndexedDB","msIndexedDB","e","getIDB","createBlob","parts","properties","Blob","name","builder","BlobBuilder","MSBlobBuilder","MozBlobBuilder","WebKitBlobBuilder","i","length","append","getBlob","type","Promise","require","Promise$1","executeCallback","promise","callback","then","result","error","executeTwoCallbacks","errorCallback","catch","normalizeKey","key","console","warn","String","getCallback","arguments","DETECT_BLOB_SUPPORT_STORE","supportsBlobs","dbContexts","toString","Object","prototype","READ_ONLY","READ_WRITE","_checkBlobSupport","resolve","txn","transaction","blob","objectStore","put","onabort","preventDefault","stopPropagation","oncomplete","matchedChrome","navigator","userAgent","match","matchedEdge","parseInt","_checkBlobSupportWithoutCaching","value","_deferReadiness","dbInfo","dbContext","deferredOperation","reject","deferredOperations","push","dbReady","_advanceReadiness","pop","_rejectReadiness","err","_getConnection","upgradeNeeded","forages","db","close","dbArgs","version","openreq","open","apply","onupgradeneeded","createObjectStore","storeName","oldVersion","ex","newVersion","onerror","onsuccess","onversionchange","target","_getOriginalConnection","_getUpgradedConnection","_isUpgradeNeeded","defaultVersion","isNewStore","objectStoreNames","contains","isDowngrade","isUpgrade","incVersion","_decodeBlob","encodedBlob","arrayBuff","bin","buf","ArrayBuffer","arr","Uint8Array","charCodeAt","_binStringToArrayBuffer","atob","data","_isEncodedBlob","__local_forage_encoded_blob","_fullyReady","self","this","_initReady","_dbInfo","createTransaction","mode","retries","undefined","tx","forage","_tryReconnect","n","ready","store","advanced","req","openKeyCursor","cursor","advance","asyncStorage","_driver","_initStorage","options","initPromises","ignoreErrors","j","slice","all","_defaultConfig","k","_support","isSafari","openDatabase","test","platform","hasFetch","fetch","indexOf","IDBKeyRange","isIndexedDBValid","iterate","iterator","openCursor","iterationNumber","continue","getItem","get","setItem","originalKey","call","blobSupport","reader","FileReader","onloadend","base64","btoa","readAsBinaryString","document","body","dispatchEvent","CustomEvent","detail","removeItem","delete","clear","count","keys","dropInstance","currentConfig","config","dbPromise","dropObjectPromise","deleteObjectStore","dropDBPromise","deleteDatabase","onblocked","BASE_CHARS","BLOB_TYPE_PREFIX_REGEX","SERIALIZED_MARKER","TYPE_ARRAYBUFFER","TYPE_BLOB","TYPE_INT8ARRAY","TYPE_UINT8ARRAY","TYPE_UINT8CLAMPEDARRAY","TYPE_INT16ARRAY","TYPE_INT32ARRAY","TYPE_UINT16ARRAY","TYPE_UINT32ARRAY","TYPE_FLOAT32ARRAY","TYPE_FLOAT64ARRAY","stringToBuffer","serializedString","encoded1","encoded2","encoded3","encoded4","bufferLength","len","p","buffer","bytes","bufferToString","base64String","substring","localforageSerializer","serialize","valueType","marker","Error","fileReader","onload","str","readAsArrayBuffer","JSON","stringify","deserialize","parse","blobType","SERIALIZED_MARKER_LENGTH","matcher","Int8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","createDbTable","t","executeSql","tryExecuteSql","sqlStatement","args","code","SYNTAX_ERR","results","rows","_setItem","retriesLeft","originalValue","serializer","sqlError","QUOTA_ERR","webSQLStorage","dbInfoPromise","description","size","item","c","storeNames","getAllStoreNames","operationInfo","dropTable","operations","_getKeyPrefix","defaultConfig","keyPrefix","_isLocalStorageUsable","localStorageTestKey","localStorage","checkIfLocalStorageThrows","localStorageWrapper","isLocalStorageValid","keyPrefixLength","itemKey","includes","array","searchElement","x","y","isNaN","isArray","Array","arg","DefinedDrivers","DriverSupport","DefaultDrivers","INDEXEDDB","idbDriver","WEBSQL","websqlDriver","LOCALSTORAGE","localstorageDriver","DefaultDriverOrder","OptionalDriverMethods","LibraryMethods","concat","DefaultConfig","driver","callWhenReady","localForageInstance","libraryMethod","_args","extend","hasOwnProperty","LocalForage","constructor","driverTypeKey","driverName","defineDriver","_config","_driverSet","_initDriver","_ready","_wrapLibraryMethodsWithReady","setDriver","replace","driverObject","complianceError","driverMethods","driverMethodName","configureMissingMethods","methodNotImplementedFactory","methodName","optionalDriverMethod","setDriverSupport","support","info","getDriver","getDriverPromise","getSerializer","serializerPromise","drivers","supportedDrivers","_getSupportedDrivers","setDriverToConfig","extendSelfWithDriver","_extend","oldDriverSetDone","currentDriverIndex","driverPromiseLoop","initDriver","supports","libraryMethodsAndProperties","createInstance","localforage"],"mappings":"AAuBA,IAAIA,EAvBJ,WAEI,IACI,GAAyB,oBAAdC,UACP,OAAOA,UAEX,GAA+B,oBAApBC,gBACP,OAAOA,gBAEX,GAA4B,oBAAjBC,aACP,OAAOA,aAEX,GAA0B,oBAAfC,WACP,OAAOA,WAEX,GAA2B,oBAAhBC,YACP,OAAOA,WAEd,CAAC,MAAOC,GACL,MACH,CACL,CAEUC,GCjBV,SAASC,EAAWC,EAAOC,GAEvBD,EAAQA,GAAS,GACjBC,EAAaA,GAAc,GAC3B,IACI,OAAO,IAAIC,KAAKF,EAAOC,EAC1B,CAAC,MAAOJ,GACL,GAAe,cAAXA,EAAEM,KACF,MAAMN,EAWV,IATA,IAQIO,EAAU,IAPa,oBAAhBC,YACDA,YACyB,oBAAlBC,cACLA,cAC0B,oBAAnBC,eACLA,eACAC,mBAELC,EAAI,EAAGA,EAAIT,EAAMU,OAAQD,GAAK,EACnCL,EAAQO,OAAOX,EAAMS,IAEzB,OAAOL,EAAQQ,QAAQX,EAAWY,KACrC,CACL,CC5BuB,oBAAZC,SAGPC,QAAQ,gBAEZ,IAAAC,EAAeF,QCPf,SAASG,EAAgBC,EAASC,GAC1BA,GACAD,EAAQE,MACJ,SAASC,GACLF,EAAS,KAAME,EAClB,IACD,SAASC,GACLH,EAASG,EACZ,GAGb,CCXA,SAASC,EAAoBL,EAASC,EAAUK,GACpB,mBAAbL,GACPD,EAAQE,KAAKD,GAGY,mBAAlBK,GACPN,EAAQO,MAAMD,EAEtB,CCRe,SAASE,EAAaC,GAOjC,MALmB,iBAARA,IACPC,QAAQC,KAAK,GAAGF,4CAChBA,EAAMG,OAAOH,IAGVA,CACX,CCRe,SAASI,IACpB,GACIC,UAAUtB,QACiC,mBAApCsB,UAAUA,UAAUtB,OAAS,GAEpC,OAAOsB,UAAUA,UAAUtB,OAAS,EAE5C,CCKA,MAAMuB,EAA4B,mCAClC,IAAIC,EACJ,MAAMC,EAAa,CAAA,EACbC,EAAWC,OAAOC,UAAUF,SAG5BG,EAAY,WACZC,EAAa,YA8DnB,SAASC,EAAkBlD,GACvB,MAA6B,kBAAlB2C,EACApB,EAAQ4B,QAAQR,GAhC/B,SAAyC3C,GACrC,OAAO,IAAIuB,GAAQ,SAAS4B,GACxB,IAAIC,EAAMpD,EAAIqD,YAAYX,EAA2BO,GACjDK,EAAO9C,EAAW,CAAC,KACvB4C,EAAIG,YAAYb,GAA2Bc,IAAIF,EAAM,OAErDF,EAAIK,QAAU,SAASnD,GAGnBA,EAAEoD,iBACFpD,EAAEqD,kBACFR,GAAQ,EACpB,EAEQC,EAAIQ,WAAa,WACb,IAAIC,EAAgBC,UAAUC,UAAUC,MAAM,iBAC1CC,EAAcH,UAAUC,UAAUC,MAAM,UAG5Cb,EACIc,IACKJ,GACDK,SAASL,EAAc,GAAI,KAAO,GAEtD,CACA,IAAO3B,OAAM,WACL,OAAO,CACf,GACA,CAMWiC,CAAgCnE,GAAK6B,MAAK,SAASuC,GAEtD,OADAzB,EAAgByB,EACTzB,CACf,GACA,CAEA,SAAS0B,EAAgBC,GACrB,IAAIC,EAAY3B,EAAW0B,EAAO1D,MAG9B4D,EAAoB,CAAA,EAExBA,EAAkB7C,QAAU,IAAIJ,GAAQ,SAAS4B,EAASsB,GACtDD,EAAkBrB,QAAUA,EAC5BqB,EAAkBC,OAASA,CACnC,IAGIF,EAAUG,mBAAmBC,KAAKH,GAG7BD,EAAUK,QAGXL,EAAUK,QAAUL,EAAUK,QAAQ/C,MAAK,WACvC,OAAO2C,EAAkB7C,OACrC,IAJQ4C,EAAUK,QAAUJ,EAAkB7C,OAM9C,CAEA,SAASkD,EAAkBP,GACvB,IAGIE,EAHY5B,EAAW0B,EAAO1D,MAGA8D,mBAAmBI,MAIrD,GAAIN,EAEA,OADAA,EAAkBrB,UACXqB,EAAkB7C,OAEjC,CAEA,SAASoD,EAAiBT,EAAQU,GAC9B,IAGIR,EAHY5B,EAAW0B,EAAO1D,MAGA8D,mBAAmBI,MAIrD,GAAIN,EAEA,OADAA,EAAkBC,OAAOO,GAClBR,EAAkB7C,OAEjC,CAEA,SAASsD,EAAeX,EAAQY,GAC5B,OAAO,IAAI3D,GAAQ,SAAS4B,EAASsB,GAGjC,GAFA7B,EAAW0B,EAAO1D,MAAQgC,EAAW0B,EAAO1D,OAmQzC,CAEHuE,QAAS,GAETC,GAAI,KAEJR,QAAS,KAETF,mBAAoB,IAzQhBJ,EAAOc,GAAI,CACX,IAAIF,EAIA,OAAO/B,EAAQmB,EAAOc,IAHtBf,EAAgBC,GAChBA,EAAOc,GAAGC,OAIjB,CAED,IAAIC,EAAS,CAAChB,EAAO1D,MAEjBsE,GACAI,EAAOX,KAAKL,EAAOiB,SAGvB,IAAIC,EAAUxF,EAAIyF,KAAKC,MAAM1F,EAAKsF,GAE9BJ,IACAM,EAAQG,gBAAkB,SAASrF,GAC/B,IAAI8E,EAAKI,EAAQ1D,OACjB,IACIsD,EAAGQ,kBAAkBtB,EAAOuB,WACxBvF,EAAEwF,YAAc,GAEhBV,EAAGQ,kBAAkBlD,EAE5B,CAAC,MAAOqD,GACL,GAAgB,oBAAZA,EAAGnF,KAcH,MAAMmF,EAbN1D,QAAQC,KACJ,iBACIgC,EAAO1D,KADX,oCAIIN,EAAEwF,WACF,eACAxF,EAAE0F,WACF,sBACA1B,EAAOuB,UACP,oBAKf,CACjB,GAGQL,EAAQS,QAAU,SAAS3F,GACvBA,EAAEoD,iBACFe,EAAOe,EAAQzD,MAC3B,EAEQyD,EAAQU,UAAY,WAChB,IAAId,EAAKI,EAAQ1D,OACjBsD,EAAGe,gBAAkB,SAAS7F,GAM1BA,EAAE8F,OAAOf,OACzB,EACYlC,EAAQiC,GACRP,EAAkBP,EAC9B,CACA,GACA,CAEA,SAAS+B,EAAuB/B,GAC5B,OAAOW,EAAeX,GAAQ,EAClC,CAEA,SAASgC,EAAuBhC,GAC5B,OAAOW,EAAeX,GAAQ,EAClC,CAEA,SAASiC,EAAiBjC,EAAQkC,GAC9B,IAAKlC,EAAOc,GACR,OAAO,EAGX,IAAIqB,GAAcnC,EAAOc,GAAGsB,iBAAiBC,SAASrC,EAAOuB,WACzDe,EAActC,EAAOiB,QAAUjB,EAAOc,GAAGG,QACzCsB,EAAYvC,EAAOiB,QAAUjB,EAAOc,GAAGG,QAqB3C,GAnBIqB,IAGItC,EAAOiB,UAAYiB,GACnBnE,QAAQC,KACJ,iBACIgC,EAAO1D,KADX,uCAII0D,EAAOc,GAAGG,QACV,eACAjB,EAAOiB,QACP,KAIZjB,EAAOiB,QAAUjB,EAAOc,GAAGG,SAG3BsB,GAAaJ,EAAY,CAIzB,GAAIA,EAAY,CACZ,IAAIK,EAAaxC,EAAOc,GAAGG,QAAU,EACjCuB,EAAaxC,EAAOiB,UACpBjB,EAAOiB,QAAUuB,EAExB,CAED,OAAO,CACV,CAED,OAAO,CACX,CAoBA,SAASC,EAAYC,GACjB,IAAIC,EArQR,SAAiCC,GAI7B,IAHA,IAAI/F,EAAS+F,EAAI/F,OACbgG,EAAM,IAAIC,YAAYjG,GACtBkG,EAAM,IAAIC,WAAWH,GAChBjG,EAAI,EAAGA,EAAIC,EAAQD,IACxBmG,EAAInG,GAAKgG,EAAIK,WAAWrG,GAE5B,OAAOiG,CACX,CA6PoBK,CAAwBC,KAAKT,EAAYU,OACzD,OAAOlH,EAAW,CAACyG,GAAY,CAAE3F,KAAM0F,EAAY1F,MACvD,CAGA,SAASqG,EAAevD,GACpB,OAAOA,GAASA,EAAMwD,2BAC1B,CAMA,SAASC,EAAYjG,GACjB,IAAIkG,EAAOC,KAEPpG,EAAUmG,EAAKE,aAAanG,MAAK,WACjC,IAAI0C,EAAY3B,EAAWkF,EAAKG,QAAQrH,MAExC,GAAI2D,GAAaA,EAAUK,QACvB,OAAOL,EAAUK,OAE7B,IAGI,OADA5C,EAAoBL,EAASC,EAAUA,GAChCD,CACX,CA6CA,SAASuG,EAAkB5D,EAAQ6D,EAAMvG,EAAUwG,QAC/BC,IAAZD,IACAA,EAAU,GAGd,IACI,IAAIE,EAAKhE,EAAOc,GAAG/B,YAAYiB,EAAOuB,UAAWsC,GACjDvG,EAAS,KAAM0G,EAClB,CAAC,MAAOtD,GACL,GACIoD,EAAU,KACR9D,EAAOc,IACQ,sBAAbJ,EAAIpE,MACS,kBAAboE,EAAIpE,MAER,OAAOW,EAAQ4B,UACVtB,MAAK,KACF,IACKyC,EAAOc,IACM,kBAAbJ,EAAIpE,OACA0D,EAAOc,GAAGsB,iBAAiBC,SACxBrC,EAAOuB,YAEXvB,EAAOiB,SAAWjB,EAAOc,GAAGG,QAOhC,OAJIjB,EAAOc,KACPd,EAAOiB,QAAUjB,EAAOc,GAAGG,QAAU,GAGlCe,EAAuBhC,EACjC,IAEJzC,MAAK,IAzEtB,SAAuByC,GACnBD,EAAgBC,GAKhB,IAHA,IAAIC,EAAY3B,EAAW0B,EAAO1D,MAC9BuE,EAAUZ,EAAUY,QAEfjE,EAAI,EAAGA,EAAIiE,EAAQhE,OAAQD,IAAK,CACrC,MAAMqH,EAASpD,EAAQjE,GACnBqH,EAAON,QAAQ7C,KACfmD,EAAON,QAAQ7C,GAAGC,QAClBkD,EAAON,QAAQ7C,GAAK,KAE3B,CAGD,OAFAd,EAAOc,GAAK,KAELiB,EAAuB/B,GACzBzC,MAAKuD,IACFd,EAAOc,GAAKA,EACRmB,EAAiBjC,GAEVgC,EAAuBhC,GAE3Bc,KAEVvD,MAAKuD,IAGFd,EAAOc,GAAKb,EAAUa,GAAKA,EAC3B,IAAK,IAAIlE,EAAI,EAAGA,EAAIiE,EAAQhE,OAAQD,IAChCiE,EAAQjE,GAAG+G,QAAQ7C,GAAKA,CAC3B,IAEJlD,OAAM8C,IAEH,MADAD,EAAiBT,EAAQU,GACnBA,CAAG,GAErB,CAsC2BwD,CAAclE,GAAQzC,MAAK,WAC9BqG,EAAkB5D,EAAQ6D,EAAMvG,EAAUwG,EAAU,EAC5E,MAEiBlG,MAAMN,GAGfA,EAASoD,EACZ,CACL,CAscA,SAAS5C,EAAIqG,EAAG7G,GACZ,IAAIkG,EAAOC,KAEPpG,EAAU,IAAIJ,GAAQ,SAAS4B,EAASsB,GACpCgE,EAAI,EACJtF,EAAQ,MAKZ2E,EACKY,QACA7G,MAAK,WACFqG,EAAkBJ,EAAKG,QAASjF,GAAW,SACvCgC,EACA3B,GAEA,GAAI2B,EACA,OAAOP,EAAOO,GAGlB,IACI,IAAI2D,EAAQtF,EAAYE,YACpBuE,EAAKG,QAAQpC,WAEb+C,GAAW,EACXC,EAAMF,EAAMG,gBAEhBD,EAAI3C,UAAY,WACZ,IAAI6C,EAASF,EAAI/G,OACZiH,EAOK,IAANN,GAKKG,EAFLzF,EAAQ4F,EAAO3G,MAKXwG,GAAW,EACXG,EAAOC,QAAQP,IAdnBtF,EAAQ,KAoBxC,EAEwB0F,EAAI5C,QAAU,WACVxB,EAAOoE,EAAI9G,MACvC,CACqB,CAAC,MAAOzB,GACLmE,EAAOnE,EACV,CACrB,GACA,IACa4B,MAAMuC,EACnB,IAGI,OADA/C,EAAgBC,EAASC,GAClBD,CACX,CA2MA,IAAIsH,EAAe,CACfC,QAAS,eACTC,aArsBJ,SAAsBC,GAClB,IAAItB,EAAOC,KACPzD,EAAS,CACTc,GAAI,MAGR,GAAIgE,EACA,IAAK,IAAIlI,KAAKkI,EACV9E,EAAOpD,GAAKkI,EAAQlI,GAK5B,IAAIqD,EAAY3B,EAAW0B,EAAO1D,MAG7B2D,IACDA,EA/BG,CAEHY,QAAS,GAETC,GAAI,KAEJR,QAAS,KAETF,mBAAoB,IAyBpB9B,EAAW0B,EAAO1D,MAAQ2D,GAI9BA,EAAUY,QAAQR,KAAKmD,GAGlBA,EAAKE,aACNF,EAAKE,WAAaF,EAAKY,MACvBZ,EAAKY,MAAQb,GAIjB,IAAIwB,EAAe,GAEnB,SAASC,IAGL,OAAO/H,EAAQ4B,SAClB,CAED,IAAK,IAAIoG,EAAI,EAAGA,EAAIhF,EAAUY,QAAQhE,OAAQoI,IAAK,CAC/C,IAAIhB,EAAShE,EAAUY,QAAQoE,GAC3BhB,IAAWT,GAEXuB,EAAa1E,KAAK4D,EAAOP,aAAa9F,MAAMoH,GAEnD,CAGD,IAAInE,EAAUZ,EAAUY,QAAQqE,MAAM,GAItC,OAAOjI,EAAQkI,IAAIJ,GACdxH,MAAK,WAGF,OAFAyC,EAAOc,GAAKb,EAAUa,GAEfiB,EAAuB/B,EAC1C,IACSzC,MAAK,SAASuD,GAEX,OADAd,EAAOc,GAAKA,EACRmB,EAAiBjC,EAAQwD,EAAK4B,eAAenE,SAEtCe,EAAuBhC,GAE3Bc,CACnB,IACSvD,MAAK,SAASuD,GACXd,EAAOc,GAAKb,EAAUa,GAAKA,EAC3B0C,EAAKG,QAAU3D,EAEf,IAAK,IAAIqF,EAAI,EAAGA,EAAIxE,EAAQhE,OAAQwI,IAAK,CACrC,IAAIpB,EAASpD,EAAQwE,GACjBpB,IAAWT,IAEXS,EAAON,QAAQ7C,GAAKd,EAAOc,GAC3BmD,EAAON,QAAQ1C,QAAUjB,EAAOiB,QAEvC,CACb,GACA,EAsnBIqE,SCtmCJ,WACI,IAGI,IAAK5J,IAAQA,EAAIyF,KACb,OAAO,EAMX,IAAIoE,EACwB,oBAAjBC,cACP,4BAA4BC,KAAKjG,UAAUC,aAC1C,SAASgG,KAAKjG,UAAUC,aACxB,aAAagG,KAAKjG,UAAUkG,UAE7BC,EACiB,mBAAVC,QACuC,IAA9CA,MAAMrH,WAAWsH,QAAQ,gBAQ7B,QACMN,GAAYI,IACO,oBAAdhK,WAKgB,oBAAhBmK,WAEd,CAAC,MAAO9J,GACL,OAAO,CACV,CACL,CD+jCc+J,GACVC,QAnkBJ,SAAiBC,EAAU3I,GACvB,IAAIkG,EAAOC,KAEPpG,EAAU,IAAIJ,GAAQ,SAAS4B,EAASsB,GACxCqD,EACKY,QACA7G,MAAK,WACFqG,EAAkBJ,EAAKG,QAASjF,GAAW,SACvCgC,EACA3B,GAEA,GAAI2B,EACA,OAAOP,EAAOO,GAGlB,IACI,IAGI6D,EAHQxF,EAAYE,YACpBuE,EAAKG,QAAQpC,WAED2E,aACZC,EAAkB,EAEtB5B,EAAI3C,UAAY,WACZ,IAAI6C,EAASF,EAAI/G,OAEjB,GAAIiH,EAAQ,CACR,IAAI3E,EAAQ2E,EAAO3E,MACfuD,EAAevD,KACfA,EAAQ2C,EAAY3C,IAExB,IAAItC,EAASyI,EACTnG,EACA2E,EAAO3G,IACPqI,UAMW,IAAX3I,EACAqB,EAAQrB,GAERiH,EAAO2B,UAE3C,MACgCvH,GAEhC,EAEwB0F,EAAI5C,QAAU,WACVxB,EAAOoE,EAAI9G,MACvC,CACqB,CAAC,MAAOzB,GACLmE,EAAOnE,EACV,CACrB,GACA,IACa4B,MAAMuC,EACnB,IAII,OAFA/C,EAAgBC,EAASC,GAElBD,CACX,EAqgBIgJ,QAtnBJ,SAAiBvI,EAAKR,GAClB,IAAIkG,EAAOC,KAEX3F,EAAMD,EAAaC,GAEnB,IAAIT,EAAU,IAAIJ,GAAQ,SAAS4B,EAASsB,GACxCqD,EACKY,QACA7G,MAAK,WACFqG,EAAkBJ,EAAKG,QAASjF,GAAW,SACvCgC,EACA3B,GAEA,GAAI2B,EACA,OAAOP,EAAOO,GAGlB,IACI,IAGI6D,EAHQxF,EAAYE,YACpBuE,EAAKG,QAAQpC,WAED+E,IAAIxI,GAEpByG,EAAI3C,UAAY,WACZ,IAAI9B,EAAQyE,EAAI/G,YACFuG,IAAVjE,IACAA,EAAQ,MAERuD,EAAevD,KACfA,EAAQ2C,EAAY3C,IAExBjB,EAAQiB,EACpC,EAEwByE,EAAI5C,QAAU,WACVxB,EAAOoE,EAAI9G,MACvC,CACqB,CAAC,MAAOzB,GACLmE,EAAOnE,EACV,CACrB,GACA,IACa4B,MAAMuC,EACnB,IAGI,OADA/C,EAAgBC,EAASC,GAClBD,CACX,EAwkBIkJ,QApgBJ,SAAiBC,EAAa1G,EAAOxC,GACjC,IAAIkG,EAAOC,KAEX3F,EAAMD,EAAa2I,GAEnB,IAAInJ,EAAU,IAAIJ,GAAQ,SAAS4B,EAASsB,GACxC,IAAIH,EACJwD,EACKY,QACA7G,MAAK,WAEF,OADAyC,EAASwD,EAAKG,QACe,kBAAzBpF,EAASkI,KAAK3G,GACPlB,EAAkBoB,EAAOc,IAAIvD,MAAK,SACrCmJ,GAEA,OAAIA,EACO5G,GA1Wdd,EA4WsBc,EA3WhC,IAAI7C,GAAQ,SAAS4B,EAASsB,GACjC,IAAIwG,EAAS,IAAIC,WACjBD,EAAOhF,QAAUxB,EACjBwG,EAAOE,UAAY,SAAS7K,GACxB,IAAI8K,EAASC,KAAK/K,EAAE8F,OAAOtE,QAAU,IACrCqB,EAAQ,CACJyE,6BAA6B,EAC7BF,KAAM0D,EACN9J,KAAMgC,EAAKhC,MAE3B,EACQ2J,EAAOK,mBAAmBhI,EAClC,KAbA,IAAqBA,CA6WrB,IAEuBc,CACvB,IACavC,MAAK,SAASuC,GACX8D,EAAkBJ,EAAKG,QAAShF,GAAY,SACxC+B,EACA3B,GAEA,GAAI2B,EACA,OAAOP,EAAOO,GAGlB,IACI,IAAI2D,EAAQtF,EAAYE,YACpBuE,EAAKG,QAAQpC,WAOH,OAAVzB,IACAA,OAAQiE,GAGZ,IAAIQ,EAAMF,EAAMnF,IAAIY,EAAOhC,GAE3BiB,EAAYO,WAAa,gBAOPyE,IAAVjE,IACAA,EAAQ,MAGZmH,SAASC,KAAKC,cACV,IAAIC,YAAY,qBAAsB,CAClCC,OAAQ,CACJhD,MAAOb,EAAKG,QAAQpC,UACpBzD,IAAK0I,MAKjB3H,EAAQiB,EACpC,EACwBf,EAAYI,QAAUJ,EAAY4C,QAAU,WACxC,IAAIjB,EAAM6D,EAAI9G,MACR8G,EAAI9G,MACJ8G,EAAIxF,YAAYtB,MACtB0C,EAAOO,EACnC,CACqB,CAAC,MAAO1E,GACLmE,EAAOnE,EACV,CACrB,GACA,IACa4B,MAAMuC,EACnB,IAGI,OADA/C,EAAgBC,EAASC,GAClBD,CACX,EAgbIiK,WA9aJ,SAAoBd,EAAalJ,GAC7B,IAAIkG,EAAOC,KAEX3F,EAAMD,EAAa2I,GAEnB,IAAInJ,EAAU,IAAIJ,GAAQ,SAAS4B,EAASsB,GACxCqD,EACKY,QACA7G,MAAK,WACFqG,EAAkBJ,EAAKG,QAAShF,GAAY,SACxC+B,EACA3B,GAEA,GAAI2B,EACA,OAAOP,EAAOO,GAGlB,IACI,IAQI6D,EARQxF,EAAYE,YACpBuE,EAAKG,QAAQpC,WAODgG,OAAOzJ,GACvBiB,EAAYO,WAAa,WACrB2H,SAASC,KAAKC,cACV,IAAIC,YAAY,qBAAsB,CAClCC,OAAQ,CACJhD,MAAOb,EAAKG,QAAQpC,UACpBzD,IAAK0I,MAKjB3H,GAC5B,EAEwBE,EAAY4C,QAAU,WAClBxB,EAAOoE,EAAI9G,MACvC,EAIwBsB,EAAYI,QAAU,WAClB,IAAIuB,EAAM6D,EAAI9G,MACR8G,EAAI9G,MACJ8G,EAAIxF,YAAYtB,MACtB0C,EAAOO,EACnC,CACqB,CAAC,MAAO1E,GACLmE,EAAOnE,EACV,CACrB,GACA,IACa4B,MAAMuC,EACnB,IAGI,OADA/C,EAAgBC,EAASC,GAClBD,CACX,EAiXImK,MA/WJ,SAAelK,GACX,IAAIkG,EAAOC,KAEPpG,EAAU,IAAIJ,GAAQ,SAAS4B,EAASsB,GACxCqD,EACKY,QACA7G,MAAK,WACFqG,EAAkBJ,EAAKG,QAAShF,GAAY,SACxC+B,EACA3B,GAEA,GAAI2B,EACA,OAAOP,EAAOO,GAGlB,IACI,IAGI6D,EAHQxF,EAAYE,YACpBuE,EAAKG,QAAQpC,WAEDiG,QAEhBzI,EAAYO,WAAa,WACrB2H,SAASC,KAAKC,cACV,IAAIC,YAAY,gBAAiB,CAC7BC,OAAQ,CAAEhD,MAAOb,EAAKG,QAAQpC,cAItC1C,GAC5B,EAEwBE,EAAYI,QAAUJ,EAAY4C,QAAU,WACxC,IAAIjB,EAAM6D,EAAI9G,MACR8G,EAAI9G,MACJ8G,EAAIxF,YAAYtB,MACtB0C,EAAOO,EACnC,CACqB,CAAC,MAAO1E,GACLmE,EAAOnE,EACV,CACrB,GACA,IACa4B,MAAMuC,EACnB,IAGI,OADA/C,EAAgBC,EAASC,GAClBD,CACX,EAiUIR,OA/TJ,SAAgBS,GACZ,IAAIkG,EAAOC,KAEPpG,EAAU,IAAIJ,GAAQ,SAAS4B,EAASsB,GACxCqD,EACKY,QACA7G,MAAK,WACFqG,EAAkBJ,EAAKG,QAASjF,GAAW,SACvCgC,EACA3B,GAEA,GAAI2B,EACA,OAAOP,EAAOO,GAGlB,IACI,IAGI6D,EAHQxF,EAAYE,YACpBuE,EAAKG,QAAQpC,WAEDkG,QAEhBlD,EAAI3C,UAAY,WACZ/C,EAAQ0F,EAAI/G,OACxC,EAEwB+G,EAAI5C,QAAU,WACVxB,EAAOoE,EAAI9G,MACvC,CACqB,CAAC,MAAOzB,GACLmE,EAAOnE,EACV,CACrB,GACA,IACa4B,MAAMuC,EACnB,IAGI,OADA/C,EAAgBC,EAASC,GAClBD,CACX,EA0RIS,IAAKA,EACL4J,KApNJ,SAAcpK,GACV,IAAIkG,EAAOC,KAEPpG,EAAU,IAAIJ,GAAQ,SAAS4B,EAASsB,GACxCqD,EACKY,QACA7G,MAAK,WACFqG,EAAkBJ,EAAKG,QAASjF,GAAW,SACvCgC,EACA3B,GAEA,GAAI2B,EACA,OAAOP,EAAOO,GAGlB,IACI,IAGI6D,EAHQxF,EAAYE,YACpBuE,EAAKG,QAAQpC,WAEDiD,gBACZkD,EAAO,GAEXnD,EAAI3C,UAAY,WACZ,IAAI6C,EAASF,EAAI/G,OAEZiH,GAKLiD,EAAKrH,KAAKoE,EAAO3G,KACjB2G,EAAO2B,YALHvH,EAAQ6I,EAMxC,EAEwBnD,EAAI5C,QAAU,WACVxB,EAAOoE,EAAI9G,MACvC,CACqB,CAAC,MAAOzB,GACLmE,EAAOnE,EACV,CACrB,GACA,IACa4B,MAAMuC,EACnB,IAGI,OADA/C,EAAgBC,EAASC,GAClBD,CACX,EAsKIsK,aApKJ,SAAsB7C,EAASxH,GAC3BA,EAAWY,EAAYkD,MAAMqC,KAAMtF,WAEnC,IAQId,EARAuK,EAAgBnE,KAAKoE,SASzB,IARA/C,EAA8B,mBAAZA,GAA0BA,GAAY,CAAA,GAC3CxI,OACTwI,EAAQxI,KAAOwI,EAAQxI,MAAQsL,EAActL,KAC7CwI,EAAQvD,UAAYuD,EAAQvD,WAAaqG,EAAcrG,WAKtDuD,EAAQxI,KAEN,CACH,MAGMwL,EAFFhD,EAAQxI,OAASsL,EAActL,MAN5BmH,KAMyCE,QAAQ7C,GAGlD7D,EAAQ4B,QATP4E,KASoBE,QAAQ7C,IAC7BiB,EAAuB+C,GAASvH,MAAKuD,IACjC,MAAMb,EAAY3B,EAAWwG,EAAQxI,MAC/BuE,EAAUZ,EAAUY,QAC1BZ,EAAUa,GAAKA,EACf,IAAK,IAAIlE,EAAI,EAAGA,EAAIiE,EAAQhE,OAAQD,IAChCiE,EAAQjE,GAAG+G,QAAQ7C,GAAKA,EAE5B,OAAOA,CAAE,IA8DfzD,EA3DCyH,EAAQvD,UA2DCuG,EAAUvK,MAAKuD,IACrB,IAAKA,EAAGsB,iBAAiBC,SAASyC,EAAQvD,WACtC,OAGJ,MAAMG,EAAaZ,EAAGG,QAAU,EAEhClB,EAAgB+E,GAEhB,MAAM7E,EAAY3B,EAAWwG,EAAQxI,MAC/BuE,EAAUZ,EAAUY,QAE1BC,EAAGC,QACH,IAAK,IAAInE,EAAI,EAAGA,EAAIiE,EAAQhE,OAAQD,IAAK,CACrC,MAAMqH,EAASpD,EAAQjE,GACvBqH,EAAON,QAAQ7C,GAAK,KACpBmD,EAAON,QAAQ1C,QAAUS,CAC5B,CAED,MAAMqG,EAAoB,IAAI9K,GAAQ,CAAC4B,EAASsB,KAC5C,MAAMoE,EAAM7I,EAAIyF,KAAK2D,EAAQxI,KAAMoF,GAEnC6C,EAAI5C,QAAUjB,IACC6D,EAAI/G,OACZuD,QACHZ,EAAOO,EAAI,EAGf6D,EAAIlD,gBAAkB,KACTkD,EAAI/G,OACVwK,kBAAkBlD,EAAQvD,UAAU,EAG3CgD,EAAI3C,UAAY,KACZ,MAAMd,EAAKyD,EAAI/G,OACfsD,EAAGC,QACHlC,EAAQiC,EAAG,CACd,IAGL,OAAOiH,EACFxK,MAAKuD,IACFb,EAAUa,GAAKA,EACf,IAAK,IAAImE,EAAI,EAAGA,EAAIpE,EAAQhE,OAAQoI,IAAK,CACrC,MAAMhB,EAASpD,EAAQoE,GACvBhB,EAAON,QAAQ7C,GAAKA,EACpBP,EAAkB0D,EAAON,QAC5B,KAEJ/F,OAAM8C,IAIH,MAFID,EAAiBqE,EAASpE,IAAQzD,EAAQ4B,WAC5CjB,OAAM,SACF8C,CAAG,GACX,IAhHAoH,EAAUvK,MAAKuD,IACrBf,EAAgB+E,GAEhB,MAAM7E,EAAY3B,EAAWwG,EAAQxI,MAC/BuE,EAAUZ,EAAUY,QAE1BC,EAAGC,QACH,IAAK,IAAInE,EAAI,EAAGA,EAAIiE,EAAQhE,OAAQD,IAAK,CACtBiE,EAAQjE,GAChB+G,QAAQ7C,GAAK,IACvB,CAED,MAAMmH,EAAgB,IAAIhL,GAAQ,CAAC4B,EAASsB,KACxC,IAAIoE,EAAM7I,EAAIwM,eAAepD,EAAQxI,MAErCiI,EAAI5C,QAAU,KACV,MAAMb,EAAKyD,EAAI/G,OACXsD,GACAA,EAAGC,QAEPZ,EAAOoE,EAAI9G,MAAM,EAGrB8G,EAAI4D,UAAY,KAGZpK,QAAQC,KACJ,sCACI8G,EAAQxI,KACR,0CACP,EAGLiI,EAAI3C,UAAY,KACZ,MAAMd,EAAKyD,EAAI/G,OACXsD,GACAA,EAAGC,QAEPlC,EAAQiC,EAAG,CACd,IAGL,OAAOmH,EACF1K,MAAKuD,IACFb,EAAUa,GAAKA,EACf,IAAK,IAAIlE,EAAI,EAAGA,EAAIiE,EAAQhE,OAAQD,IAAK,CAErC2D,EADeM,EAAQjE,GACE+G,QAC5B,KAEJ/F,OAAM8C,IAIH,MAFID,EAAiBqE,EAASpE,IAAQzD,EAAQ4B,WAC5CjB,OAAM,SACF8C,CAAG,GACX,GA4DjB,MArIGrD,EAAUJ,EAAQkD,OAAO,qBAwI7B,OADA/C,EAAgBC,EAASC,GAClBD,CACX,GE7lCA,IAAI+K,EACA,mEAGAC,EAAyB,gCAEzBC,EAAoB,YAIpBC,EAAmB,OACnBC,EAAY,OACZC,EAAiB,OACjBC,EAAkB,OAClBC,EAAyB,OACzBC,EAAkB,OAClBC,EAAkB,OAClBC,EAAmB,OACnBC,EAAmB,OACnBC,EAAoB,OACpBC,EAAoB,OAIpB1K,EAAWC,OAAOC,UAAUF,SAEhC,SAAS2K,EAAeC,GAEpB,IAEIvM,EAEAwM,EAAUC,EAAUC,EAAUC,EAJ9BC,EAAyC,IAA1BL,EAAiBtM,OAChC4M,EAAMN,EAAiBtM,OAEvB6M,EAAI,EAG8C,MAAlDP,EAAiBA,EAAiBtM,OAAS,KAC3C2M,IACsD,MAAlDL,EAAiBA,EAAiBtM,OAAS,IAC3C2M,KAIR,IAAIG,EAAS,IAAI7G,YAAY0G,GACzBI,EAAQ,IAAI5G,WAAW2G,GAE3B,IAAK/M,EAAI,EAAGA,EAAI6M,EAAK7M,GAAK,EACtBwM,EAAWhB,EAAWvC,QAAQsD,EAAiBvM,IAC/CyM,EAAWjB,EAAWvC,QAAQsD,EAAiBvM,EAAI,IACnD0M,EAAWlB,EAAWvC,QAAQsD,EAAiBvM,EAAI,IACnD2M,EAAWnB,EAAWvC,QAAQsD,EAAiBvM,EAAI,IAGnDgN,EAAMF,KAAQN,GAAY,EAAMC,GAAY,EAC5CO,EAAMF,MAAoB,GAAXL,IAAkB,EAAMC,GAAY,EACnDM,EAAMF,MAAoB,EAAXJ,IAAiB,EAAiB,GAAXC,EAE1C,OAAOI,CACX,CAIA,SAASE,EAAeF,GAEpB,IAEI/M,EAFAgN,EAAQ,IAAI5G,WAAW2G,GACvBG,EAAe,GAGnB,IAAKlN,EAAI,EAAGA,EAAIgN,EAAM/M,OAAQD,GAAK,EAE/BkN,GAAgB1B,EAAWwB,EAAMhN,IAAM,GACvCkN,GAAgB1B,GAAwB,EAAXwB,EAAMhN,KAAW,EAAMgN,EAAMhN,EAAI,IAAM,GACpEkN,GACI1B,GAA4B,GAAfwB,EAAMhN,EAAI,KAAY,EAAMgN,EAAMhN,EAAI,IAAM,GAC7DkN,GAAgB1B,EAA0B,GAAfwB,EAAMhN,EAAI,IAUzC,OAPIgN,EAAM/M,OAAS,GAAM,EACrBiN,EAAeA,EAAaC,UAAU,EAAGD,EAAajN,OAAS,GAAK,IAC7D+M,EAAM/M,OAAS,GAAM,IAC5BiN,EACIA,EAAaC,UAAU,EAAGD,EAAajN,OAAS,GAAK,MAGtDiN,CACX,CAoJA,IAAIE,EAAwB,CACxBC,UAhJJ,SAAmBnK,EAAOxC,GACtB,IAAI4M,EAAY,GAShB,GARIpK,IACAoK,EAAY3L,EAASkI,KAAK3G,IAQ1BA,IACe,yBAAdoK,GACIpK,EAAM6J,QAC6B,yBAAhCpL,EAASkI,KAAK3G,EAAM6J,SAC9B,CAGE,IAAIA,EACAQ,EAAS7B,EAETxI,aAAiBgD,aACjB6G,EAAS7J,EACTqK,GAAU5B,IAEVoB,EAAS7J,EAAM6J,OAEG,uBAAdO,EACAC,GAAU1B,EACW,wBAAdyB,EACPC,GAAUzB,EACW,+BAAdwB,EACPC,GAAUxB,EACW,wBAAduB,EACPC,GAAUvB,EACW,yBAAdsB,EACPC,GAAUrB,EACW,wBAAdoB,EACPC,GAAUtB,EACW,yBAAdqB,EACPC,GAAUpB,EACW,0BAAdmB,EACPC,GAAUnB,EACW,0BAAdkB,EACPC,GAAUlB,EAEV3L,EAAS,IAAI8M,MAAM,wCAI3B9M,EAAS6M,EAASN,EAAeF,GACzC,MAAW,GAAkB,kBAAdO,EAA+B,CAEtC,IAAIG,EAAa,IAAIzD,WAErByD,EAAWC,OAAS,WAEhB,IAAIC,EA9IO,uBAgJPzK,EAAM9C,KACN,IACA6M,EAAepG,KAAKjG,QAExBF,EAASgL,EAAoBE,EAAY+B,EACrD,EAEQF,EAAWG,kBAAkB1K,EACrC,MACQ,IACIxC,EAASmN,KAAKC,UAAU5K,GAC3B,CAAC,MAAO9D,GACL+B,QAAQN,MAAM,8CAA+CqC,GAE7DxC,EAAS,KAAMtB,EAClB,CAET,EAqEI2O,YA3DJ,SAAqB7K,GAIjB,GAAIA,EAAMiK,UAAU,EA3KOzB,KA2K0BA,EACjD,OAAOmC,KAAKG,MAAM9K,GAMtB,IAMI+K,EANA1B,EAAmBrJ,EAAMiK,UAnK7Be,IAoKI9N,EAAO8C,EAAMiK,UAnLUzB,EAe3BwC,IA4KA,GAAI9N,IAASwL,GAAaH,EAAuB5C,KAAK0D,GAAmB,CACrE,IAAI4B,EAAU5B,EAAiBzJ,MAAM2I,GACrCwC,EAAWE,EAAQ,GACnB5B,EAAmBA,EAAiBY,UAAUgB,EAAQ,GAAGlO,OAC5D,CACD,IAAI8M,EAAST,EAAeC,GAI5B,OAAQnM,GACJ,KAAKuL,EACD,OAAOoB,EACX,KAAKnB,EACD,OAAOtM,EAAW,CAACyN,GAAS,CAAE3M,KAAM6N,IACxC,KAAKpC,EACD,OAAO,IAAIuC,UAAUrB,GACzB,KAAKjB,EACD,OAAO,IAAI1F,WAAW2G,GAC1B,KAAKhB,EACD,OAAO,IAAIsC,kBAAkBtB,GACjC,KAAKf,EACD,OAAO,IAAIsC,WAAWvB,GAC1B,KAAKb,EACD,OAAO,IAAIqC,YAAYxB,GAC3B,KAAKd,EACD,OAAO,IAAIuC,WAAWzB,GAC1B,KAAKZ,EACD,OAAO,IAAIsC,YAAY1B,GAC3B,KAAKX,EACD,OAAO,IAAIsC,aAAa3B,GAC5B,KAAKV,EACD,OAAO,IAAIsC,aAAa5B,GAC5B,QACI,MAAM,IAAIS,MAAM,gBAAkBpN,GAE9C,EAKIkM,eAAgBA,EAChBW,eAAgBA,GChOpB,SAAS2B,EAAcC,EAAGzL,EAAQ1C,EAAUK,GACxC8N,EAAEC,WACE,8BAA8B1L,EAAOuB,wDAErC,GACAjE,EACAK,EAER,CAqDA,SAASgO,EAAcF,EAAGzL,EAAQ4L,EAAcC,EAAMvO,EAAUK,GAC5D8N,EAAEC,WACEE,EACAC,EACAvO,GACA,SAASmO,EAAGhO,GACJA,EAAMqO,OAASrO,EAAMsO,WACrBN,EAAEC,WACE,iEAEA,CAAC1L,EAAOuB,YACR,SAASkK,EAAGO,GACHA,EAAQC,KAAKpP,OAiBdc,EAAc8N,EAAGhO,GAdjB+N,EACIC,EACAzL,GACA,WACIyL,EAAEC,WACEE,EACAC,EACAvO,EACAK,EAEP,GACDA,EAKX,GACDA,GAGJA,EAAc8N,EAAGhO,EAExB,GACDE,EAER,CAsGA,SAASuO,EAASpO,EAAKgC,EAAOxC,EAAU6O,GACpC,IAAI3I,EAAOC,KAEX3F,EAAMD,EAAaC,GAEnB,IAAIT,EAAU,IAAIJ,GAAQ,SAAS4B,EAASsB,GACxCqD,EACKY,QACA7G,MAAK,gBAIYwG,IAAVjE,IACAA,EAAQ,MAIZ,IAAIsM,EAAgBtM,EAEhBE,EAASwD,EAAKG,QAClB3D,EAAOqM,WAAWpC,UAAUnK,GAAO,SAASA,EAAOrC,GAC3CA,EACA0C,EAAO1C,GAEPuC,EAAOc,GAAG/B,aACN,SAAS0M,GACLE,EACIF,EACAzL,EACA,0BACIA,EAAOuB,uCAEX,CAACzD,EAAKgC,IACN,WACIjB,EAAQuN,EACX,IACD,SAASX,EAAGhO,GACR0C,EAAO1C,EACV,GAER,IACD,SAAS6O,GAGL,GAAIA,EAASR,OAASQ,EAASC,UAAW,CAQtC,GAAIJ,EAAc,EASd,YARAtN,EACIqN,EAAS9K,MAAMoC,EAAM,CACjB1F,EACAsO,EACA9O,EACA6O,EAAc,KAK1BhM,EAAOmM,EACV,CACJ,GAG7B,GACA,IACa1O,MAAMuC,EACnB,IAGI,OADA/C,EAAgBC,EAASC,GAClBD,CACX,CA2SA,IAAImP,EAAgB,CAChB5H,QAAS,gBACTC,aAvjBJ,SAAsBC,GAClB,IAAItB,EAAOC,KACPzD,EAAS,CACTc,GAAI,MAGR,GAAIgE,EACA,IAAK,IAAIlI,KAAKkI,EACV9E,EAAOpD,GACmB,iBAAfkI,EAAQlI,GACTkI,EAAQlI,GAAG2B,WACXuG,EAAQlI,GAI1B,IAAI6P,EAAgB,IAAIxP,GAAQ,SAAS4B,EAASsB,GAG9C,IACIH,EAAOc,GAAK0E,aACRxF,EAAO1D,KACP2B,OAAO+B,EAAOiB,SACdjB,EAAO0M,YACP1M,EAAO2M,KAEd,CAAC,MAAO3Q,GACL,OAAOmE,EAAOnE,EACjB,CAGDgE,EAAOc,GAAG/B,aAAY,SAAS0M,GAC3BD,EACIC,EACAzL,GACA,WACIwD,EAAKG,QAAU3D,EACfnB,GACH,IACD,SAAS4M,EAAGhO,GACR0C,EAAO1C,EACV,GAER,GAAE0C,EACX,IAGI,OADAH,EAAOqM,WAAaA,EACbI,CACX,EAygBInH,SCplB+B,mBAAjBE,aDqlBdQ,QAlbJ,SAAiBC,EAAU3I,GACvB,IAAIkG,EAAOC,KAEPpG,EAAU,IAAIJ,GAAQ,SAAS4B,EAASsB,GACxCqD,EACKY,QACA7G,MAAK,WACF,IAAIyC,EAASwD,EAAKG,QAElB3D,EAAOc,GAAG/B,aAAY,SAAS0M,GAC3BE,EACIF,EACAzL,EACA,iBAAiBA,EAAOuB,YACxB,IACA,SAASkK,EAAGO,GAIR,IAHA,IAAIC,EAAOD,EAAQC,KACfpP,EAASoP,EAAKpP,OAETD,EAAI,EAAGA,EAAIC,EAAQD,IAAK,CAC7B,IAAIgQ,EAAOX,EAAKW,KAAKhQ,GACjBY,EAASoP,EAAK9M,MAclB,GAVItC,IACAA,EAASwC,EAAOqM,WAAW1B,YACvBnN,SAQO,KAJfA,EAASyI,EAASzI,EAAQoP,EAAK9O,IAAKlB,EAAI,IAMpC,YADAiC,EAAQrB,EAGf,CAEDqB,GACH,IACD,SAAS4M,EAAGhO,GACR0C,EAAO1C,EACV,GAEzB,GACA,IACaG,MAAMuC,EACnB,IAGI,OADA/C,EAAgBC,EAASC,GAClBD,CACX,EA6XIgJ,QA/dJ,SAAiBvI,EAAKR,GAClB,IAAIkG,EAAOC,KAEX3F,EAAMD,EAAaC,GAEnB,IAAIT,EAAU,IAAIJ,GAAQ,SAAS4B,EAASsB,GACxCqD,EACKY,QACA7G,MAAK,WACF,IAAIyC,EAASwD,EAAKG,QAClB3D,EAAOc,GAAG/B,aAAY,SAAS0M,GAC3BE,EACIF,EACAzL,EACA,iBACIA,EAAOuB,kCAEX,CAACzD,IACD,SAAS2N,EAAGO,GACR,IAAIxO,EAASwO,EAAQC,KAAKpP,OACpBmP,EAAQC,KAAKW,KAAK,GAAG9M,MACrB,KAIFtC,IACAA,EAASwC,EAAOqM,WAAW1B,YAAYnN,IAG3CqB,EAAQrB,EACX,IACD,SAASiO,EAAGhO,GACR0C,EAAO1C,EACV,GAEzB,GACA,IACaG,MAAMuC,EACnB,IAGI,OADA/C,EAAgBC,EAASC,GAClBD,CACX,EAsbIkJ,QA/SJ,SAAiBzI,EAAKgC,EAAOxC,GACzB,OAAO4O,EAAS9K,MAAMqC,KAAM,CAAC3F,EAAKgC,EAAOxC,EAAU,GACvD,EA8SIgK,WA5SJ,SAAoBxJ,EAAKR,GACrB,IAAIkG,EAAOC,KAEX3F,EAAMD,EAAaC,GAEnB,IAAIT,EAAU,IAAIJ,GAAQ,SAAS4B,EAASsB,GACxCqD,EACKY,QACA7G,MAAK,WACF,IAAIyC,EAASwD,EAAKG,QAClB3D,EAAOc,GAAG/B,aAAY,SAAS0M,GAC3BE,EACIF,EACAzL,EACA,eAAeA,EAAOuB,0BACtB,CAACzD,IACD,WACIe,GACH,IACD,SAAS4M,EAAGhO,GACR0C,EAAO1C,EACV,GAEzB,GACA,IACaG,MAAMuC,EACnB,IAGI,OADA/C,EAAgBC,EAASC,GAClBD,CACX,EA+QImK,MA3QJ,SAAelK,GACX,IAAIkG,EAAOC,KAEPpG,EAAU,IAAIJ,GAAQ,SAAS4B,EAASsB,GACxCqD,EACKY,QACA7G,MAAK,WACF,IAAIyC,EAASwD,EAAKG,QAClB3D,EAAOc,GAAG/B,aAAY,SAAS0M,GAC3BE,EACIF,EACAzL,EACA,eAAeA,EAAOuB,YACtB,IACA,WACI1C,GACH,IACD,SAAS4M,EAAGhO,GACR0C,EAAO1C,EACV,GAEzB,GACA,IACaG,MAAMuC,EACnB,IAGI,OADA/C,EAAgBC,EAASC,GAClBD,CACX,EAgPIR,OA5OJ,SAAgBS,GACZ,IAAIkG,EAAOC,KAEPpG,EAAU,IAAIJ,GAAQ,SAAS4B,EAASsB,GACxCqD,EACKY,QACA7G,MAAK,WACF,IAAIyC,EAASwD,EAAKG,QAClB3D,EAAOc,GAAG/B,aAAY,SAAS0M,GAE3BE,EACIF,EACAzL,EACA,+BAA+BA,EAAOuB,YACtC,IACA,SAASkK,EAAGO,GACR,IAAIxO,EAASwO,EAAQC,KAAKW,KAAK,GAAGC,EAClChO,EAAQrB,EACX,IACD,SAASiO,EAAGhO,GACR0C,EAAO1C,EACV,GAEzB,GACA,IACaG,MAAMuC,EACnB,IAGI,OADA/C,EAAgBC,EAASC,GAClBD,CACX,EA+MIS,IAtMJ,SAAaqG,EAAG7G,GACZ,IAAIkG,EAAOC,KAEPpG,EAAU,IAAIJ,GAAQ,SAAS4B,EAASsB,GACxCqD,EACKY,QACA7G,MAAK,WACF,IAAIyC,EAASwD,EAAKG,QAClB3D,EAAOc,GAAG/B,aAAY,SAAS0M,GAC3BE,EACIF,EACAzL,EACA,mBACIA,EAAOuB,iCAEX,CAAC4C,EAAI,IACL,SAASsH,EAAGO,GACR,IAAIxO,EAASwO,EAAQC,KAAKpP,OACpBmP,EAAQC,KAAKW,KAAK,GAAG9O,IACrB,KACNe,EAAQrB,EACX,IACD,SAASiO,EAAGhO,GACR0C,EAAO1C,EACV,GAEzB,GACA,IACaG,MAAMuC,EACnB,IAGI,OADA/C,EAAgBC,EAASC,GAClBD,CACX,EAsKIqK,KApKJ,SAAcpK,GACV,IAAIkG,EAAOC,KAEPpG,EAAU,IAAIJ,GAAQ,SAAS4B,EAASsB,GACxCqD,EACKY,QACA7G,MAAK,WACF,IAAIyC,EAASwD,EAAKG,QAClB3D,EAAOc,GAAG/B,aAAY,SAAS0M,GAC3BE,EACIF,EACAzL,EACA,mBAAmBA,EAAOuB,YAC1B,IACA,SAASkK,EAAGO,GAGR,IAFA,IAAItE,EAAO,GAEF9K,EAAI,EAAGA,EAAIoP,EAAQC,KAAKpP,OAAQD,IACrC8K,EAAKrH,KAAK2L,EAAQC,KAAKW,KAAKhQ,GAAGkB,KAGnCe,EAAQ6I,EACX,IACD,SAAS+D,EAAGhO,GACR0C,EAAO1C,EACV,GAEzB,GACA,IACaG,MAAMuC,EACnB,IAGI,OADA/C,EAAgBC,EAASC,GAClBD,CACX,EAmIIsK,aA/FJ,SAAsB7C,EAASxH,GAC3BA,EAAWY,EAAYkD,MAAMqC,KAAMtF,WAEnC,IAAIyJ,EAAgBnE,KAAKoE,UACzB/C,EAA8B,mBAAZA,GAA0BA,GAAY,CAAA,GAC3CxI,OACTwI,EAAQxI,KAAOwI,EAAQxI,MAAQsL,EAActL,KAC7CwI,EAAQvD,UAAYuD,EAAQvD,WAAaqG,EAAcrG,WAG3D,IACIlE,EADAmG,EAAOC,KAsEX,OADArG,EAhEIC,EAHCyH,EAAQxI,KAGC,IAAIW,GAAQ,SAAS4B,GAC3B,IAAIiC,EAGAA,EAFAgE,EAAQxI,OAASsL,EAActL,KAE1BkH,EAAKG,QAAQ7C,GAEb0E,aAAaV,EAAQxI,KAAM,GAAI,GAAI,GAGvCwI,EAAQvD,UAIT1C,EAAQ,CACJiC,KACAgM,WAAY,CAAChI,EAAQvD,aAJzB1C,EA1DhB,SAA0BiC,GACtB,OAAO,IAAI7D,GAAQ,SAAS4B,EAASsB,GACjCW,EAAG/B,aACC,SAAS0M,GACLA,EAAEC,WACE,8FAEA,IACA,SAASD,EAAGO,GAGR,IAFA,IAAIc,EAAa,GAERlQ,EAAI,EAAGA,EAAIoP,EAAQC,KAAKpP,OAAQD,IACrCkQ,EAAWzM,KAAK2L,EAAQC,KAAKW,KAAKhQ,GAAGN,MAGzCuC,EAAQ,CACJiC,KACAgM,cAEP,IACD,SAASrB,EAAGhO,GACR0C,EAAO1C,EACV,GAER,IACD,SAAS6O,GACLnM,EAAOmM,EACV,GAEb,GACA,CA4BwBS,CAAiBjM,GAOzC,IAAWvD,MAAK,SAASyP,GACb,OAAO,IAAI/P,GAAQ,SAAS4B,EAASsB,GACjC6M,EAAclM,GAAG/B,aACb,SAAS0M,GACL,SAASwB,EAAU1L,GACf,OAAO,IAAItE,GAAQ,SAAS4B,EAASsB,GACjCsL,EAAEC,WACE,wBAAwBnK,IACxB,IACA,WACI1C,GACH,IACD,SAAS4M,EAAGhO,GACR0C,EAAO1C,EACV,GAErC,GACyB,CAGD,IADA,IAAIyP,EAAa,GAETtQ,EAAI,EAAG6M,EAAMuD,EAAcF,WAAWjQ,OAC1CD,EAAI6M,EACJ7M,IAEAsQ,EAAW7M,KACP4M,EAAUD,EAAcF,WAAWlQ,KAI3CK,EAAQkI,IAAI+H,GACP3P,MAAK,WACFsB,GAChC,IAC6BjB,OAAM,SAAS5B,GACZmE,EAAOnE,EACvC,GACqB,IACD,SAASsQ,GACLnM,EAAOmM,EACV,GAErB,GACA,IA/DkBrP,EAAQkD,OAAO,qBAkEJ7C,GAClBD,CACX,GEpkBA,SAAS8P,EAAcrI,EAASsI,GAC5B,IAAIC,EAAYvI,EAAQxI,KAAO,IAK/B,OAHIwI,EAAQvD,YAAc6L,EAAc7L,YACpC8L,GAAavI,EAAQvD,UAAY,KAE9B8L,CACX,CAoBA,SAASC,IACL,OAlBJ,WACI,IAAIC,EAAsB,4BAE1B,IAII,OAHAC,aAAajH,QAAQgH,GAAqB,GAC1CC,aAAalG,WAAWiG,IAEjB,CACV,CAAC,MAAOvR,GACL,OAAO,CACV,CACL,CAOYyR,IAA+BD,aAAa3Q,OAAS,CACjE,CAmRA,IAAI6Q,EAAsB,CACtB9I,QAAS,sBACTC,aAlRJ,SAAsBC,GAClB,IACI9E,EAAS,CAAA,EACb,GAAI8E,EACA,IAAK,IAAIlI,KAAKkI,EACV9E,EAAOpD,GAAKkI,EAAQlI,GAM5B,OAFAoD,EAAOqN,UAAYF,EAAcrI,EARtBrB,KAQoC2B,gBAE1CkI,KAVM7J,KAcNE,QAAU3D,EACfA,EAAOqM,WAAaA,EAEbpP,EAAQ4B,WANJ5B,EAAQkD,QAOvB,EAgQImF,SC/TJ,WACI,IACI,MAC4B,oBAAjBkI,cACP,YAAaA,gBAEXA,aAAajH,OAEtB,CAAC,MAAOvK,GACL,OAAO,CACV,CACL,CDoTc2R,GACV3H,QA/MJ,SAAiBC,EAAU3I,GACvB,IAAIkG,EAAOC,KAEPpG,EAAUmG,EAAKY,QAAQ7G,MAAK,WAc5B,IAbA,IAAIyC,EAASwD,EAAKG,QACd0J,EAAYrN,EAAOqN,UACnBO,EAAkBP,EAAUxQ,OAC5BA,EAAS2Q,aAAa3Q,OAQtBsJ,EAAkB,EAEbvJ,EAAI,EAAGA,EAAIC,EAAQD,IAAK,CAC7B,IAAIkB,EAAM0P,aAAa1P,IAAIlB,GAC3B,GAA+B,IAA3BkB,EAAI+H,QAAQwH,GAAhB,CAGA,IAAIvN,EAAQ0N,aAAanH,QAAQvI,GAgBjC,GAVIgC,IACAA,EAAQE,EAAOqM,WAAW1B,YAAY7K,SAS5B,KANdA,EAAQmG,EACJnG,EACAhC,EAAIiM,UAAU6D,GACdzH,MAIA,OAAOrG,CAlBV,CAoBJ,CACT,IAGI,OADA1C,EAAgBC,EAASC,GAClBD,CACX,EAkKIgJ,QAzOJ,SAAiBvI,EAAKR,GAClB,IAAIkG,EAAOC,KAEX3F,EAAMD,EAAaC,GAEnB,IAAIT,EAAUmG,EAAKY,QAAQ7G,MAAK,WAC5B,IAAIyC,EAASwD,EAAKG,QACdnG,EAASgQ,aAAanH,QAAQrG,EAAOqN,UAAYvP,GAUrD,OAJIN,IACAA,EAASwC,EAAOqM,WAAW1B,YAAYnN,IAGpCA,CACf,IAGI,OADAJ,EAAgBC,EAASC,GAClBD,CACX,EAoNIkJ,QAtFJ,SAAiBzI,EAAKgC,EAAOxC,GACzB,IAAIkG,EAAOC,KAEX3F,EAAMD,EAAaC,GAEnB,IAAIT,EAAUmG,EAAKY,QAAQ7G,MAAK,gBAGdwG,IAAVjE,IACAA,EAAQ,MAIZ,IAAIsM,EAAgBtM,EAEpB,OAAO,IAAI7C,GAAQ,SAAS4B,EAASsB,GACjC,IAAIH,EAASwD,EAAKG,QAClB3D,EAAOqM,WAAWpC,UAAUnK,GAAO,SAASA,EAAOrC,GAC/C,GAAIA,EACA0C,EAAO1C,QAEP,IACI+P,aAAajH,QAAQvG,EAAOqN,UAAYvP,EAAKgC,GAC7CjB,EAAQuN,EACX,CAAC,MAAOpQ,GAIU,uBAAXA,EAAEM,MACS,+BAAXN,EAAEM,MAEF6D,EAAOnE,GAEXmE,EAAOnE,EACV,CAErB,GACA,GACA,IAGI,OADAoB,EAAgBC,EAASC,GAClBD,CACX,EA6CIiK,WAzGJ,SAAoBxJ,EAAKR,GACrB,IAAIkG,EAAOC,KAEX3F,EAAMD,EAAaC,GAEnB,IAAIT,EAAUmG,EAAKY,QAAQ7G,MAAK,WAC5B,IAAIyC,EAASwD,EAAKG,QAClB6J,aAAalG,WAAWtH,EAAOqN,UAAYvP,EACnD,IAGI,OADAV,EAAgBC,EAASC,GAClBD,CACX,EA8FImK,MAjQJ,SAAelK,GACX,IAAIkG,EAAOC,KACPpG,EAAUmG,EAAKY,QAAQ7G,MAAK,WAG5B,IAFA,IAAI8P,EAAY7J,EAAKG,QAAQ0J,UAEpBzQ,EAAI4Q,aAAa3Q,OAAS,EAAGD,GAAK,EAAGA,IAAK,CAC/C,IAAIkB,EAAM0P,aAAa1P,IAAIlB,GAEI,IAA3BkB,EAAI+H,QAAQwH,IACZG,aAAalG,WAAWxJ,EAE/B,CACT,IAGI,OADAV,EAAgBC,EAASC,GAClBD,CACX,EAkPIR,OAtHJ,SAAgBS,GACZ,IACID,EADOoG,KACQiE,OAAOnK,MAAK,SAASmK,GACpC,OAAOA,EAAK7K,MACpB,IAGI,OADAO,EAAgBC,EAASC,GAClBD,CACX,EA+GIS,IApKJ,SAAaqG,EAAG7G,GACZ,IAAIkG,EAAOC,KACPpG,EAAUmG,EAAKY,QAAQ7G,MAAK,WAC5B,IACIC,EADAwC,EAASwD,EAAKG,QAElB,IACInG,EAASgQ,aAAa1P,IAAIqG,EAC7B,CAAC,MAAO1G,GACLD,EAAS,IACZ,CAOD,OAJIA,IACAA,EAASA,EAAOuM,UAAU/J,EAAOqN,UAAUxQ,SAGxCW,CACf,IAGI,OADAJ,EAAgBC,EAASC,GAClBD,CACX,EAgJIqK,KA9IJ,SAAcpK,GACV,IAAIkG,EAAOC,KACPpG,EAAUmG,EAAKY,QAAQ7G,MAAK,WAK5B,IAJA,IAAIyC,EAASwD,EAAKG,QACd9G,EAAS2Q,aAAa3Q,OACtB6K,EAAO,GAEF9K,EAAI,EAAGA,EAAIC,EAAQD,IAAK,CAC7B,IAAIiR,EAAUL,aAAa1P,IAAIlB,GACW,IAAtCiR,EAAQhI,QAAQ7F,EAAOqN,YACvB3F,EAAKrH,KAAKwN,EAAQ9D,UAAU/J,EAAOqN,UAAUxQ,QAEpD,CAED,OAAO6K,CACf,IAGI,OADAtK,EAAgBC,EAASC,GAClBD,CACX,EA4HIsK,aAhDJ,SAAsB7C,EAASxH,GAI3B,GAHAA,EAAWY,EAAYkD,MAAMqC,KAAMtF,aAEnC2G,EAA8B,mBAAZA,GAA0BA,GAAY,CAAA,GAC3CxI,KAAM,CACf,IAAIsL,EAAgBnE,KAAKoE,SACzB/C,EAAQxI,KAAOwI,EAAQxI,MAAQsL,EAActL,KAC7CwI,EAAQvD,UAAYuD,EAAQvD,WAAaqG,EAAcrG,SAC1D,CAED,IACIlE,EADAmG,EAAOC,KAuBX,OAlBIpG,EAHCyH,EAAQxI,KAGC,IAAIW,GAAQ,SAAS4B,GACtBiG,EAAQvD,UAGT1C,EAAQsO,EAAcrI,EAAStB,EAAK4B,iBAFpCvG,EAAQ,GAAGiG,EAAQxI,QAInC,IAAWiB,MAAK,SAAS8P,GACb,IAAK,IAAIzQ,EAAI4Q,aAAa3Q,OAAS,EAAGD,GAAK,EAAGA,IAAK,CAC/C,IAAIkB,EAAM0P,aAAa1P,IAAIlB,GAEI,IAA3BkB,EAAI+H,QAAQwH,IACZG,aAAalG,WAAWxJ,EAE/B,CACb,IAhBkBb,EAAQkD,OAAO,qBAmB7B/C,EAAgBC,EAASC,GAClBD,CACX,GE1TA,MAIMyQ,EAAW,CAACC,EAAOC,KACrB,MAAMvE,EAAMsE,EAAMlR,OAClB,IAAID,EAAI,EACR,KAAOA,EAAI6M,GAAK,CACZ,IARWwE,EAQGF,EAAMnR,OARNsR,EAQUF,IANd,iBAANC,GAA+B,iBAANC,GAAkBC,MAAMF,IAAME,MAAMD,GAO7D,OAAO,EAEXtR,GACH,CAZa,IAACqR,EAAGC,EAclB,OAAO,CAAK,ECdVE,EACFC,MAAMD,SACN,SAASE,GACL,MAA+C,mBAAxC9P,OAAOC,UAAUF,SAASkI,KAAK6H,EACzC,ECQCC,GAAiB,CAAA,EAEjBC,GAAgB,CAAA,EAEhBC,GAAiB,CACnBC,UAAWC,EACXC,OAAQC,EACRC,aAAcC,GAGZC,GAAqB,CACvBP,GAAeC,UAAU9J,QACzB6J,GAAeG,OAAOhK,QACtB6J,GAAeK,aAAalK,SAG1BqK,GAAwB,CAAC,gBAEzBC,GAAiB,CACnB,QACA,UACA,UACA,MACA,OACA,SACA,aACA,WACFC,OAAOF,IAEHG,GAAgB,CAClB1C,YAAa,GACb2C,OAAQL,GAAmB9J,QAC3B5I,KAAM,cAGNqQ,KAAM,QACNpL,UAAW,gBACXN,QAAS,GAGb,SAASqO,GAAcC,EAAqBC,GACxCD,EAAoBC,GAAiB,WACjC,MAAMC,EAAQtR,UACd,OAAOoR,EAAoBnL,QAAQ7G,MAAK,WACpC,OAAOgS,EAAoBC,GAAepO,MACtCmO,EACAE,EAEhB,GACA,CACA,CAEA,SAASC,KACL,IAAK,IAAI9S,EAAI,EAAGA,EAAIuB,UAAUtB,OAAQD,IAAK,CACvC,MAAM0R,EAAMnQ,UAAUvB,GAEtB,GAAI0R,EACA,IAAK,IAAIxQ,KAAOwQ,EACRA,EAAIqB,eAAe7R,KACfsQ,EAAQE,EAAIxQ,IACZK,UAAU,GAAGL,GAAOwQ,EAAIxQ,GAAKoH,QAE7B/G,UAAU,GAAGL,GAAOwQ,EAAIxQ,GAK3C,CAED,OAAOK,UAAU,EACrB,CAEA,MAAMyR,GACF,WAAAC,CAAY/K,GACR,IAAK,IAAIgL,KAAiBrB,GACtB,GAAIA,GAAekB,eAAeG,GAAgB,CAC9C,MAAMT,EAASZ,GAAeqB,GACxBC,EAAaV,EAAOzK,QAC1BnB,KAAKqM,GAAiBC,EAEjBxB,GAAewB,IAIhBtM,KAAKuM,aAAaX,EAEzB,CAGL5L,KAAK2B,eAAiBsK,GAAO,CAAE,EAAEN,IACjC3L,KAAKwM,QAAUP,GAAO,CAAA,EAAIjM,KAAK2B,eAAgBN,GAC/CrB,KAAKyM,WAAa,KAClBzM,KAAK0M,YAAc,KACnB1M,KAAK2M,QAAS,EACd3M,KAAKE,QAAU,KAEfF,KAAK4M,+BACL5M,KAAK6M,UAAU7M,KAAKwM,QAAQZ,QAAQzR,OAAM,QAC7C,CAMD,MAAAiK,CAAO/C,GAIH,GAAuB,iBAAZA,EAAsB,CAG7B,GAAIrB,KAAK2M,OACL,OAAO,IAAIhG,MACP,wDAIR,IAAK,IAAIxN,KAAKkI,EAAS,CAKnB,GAJU,cAANlI,IACAkI,EAAQlI,GAAKkI,EAAQlI,GAAG2T,QAAQ,MAAO,MAGjC,YAAN3T,GAAyC,iBAAfkI,EAAQlI,GAClC,OAAO,IAAIwN,MAAM,sCAGrB3G,KAAKwM,QAAQrT,GAAKkI,EAAQlI,EAC7B,CAID,QAAI,WAAYkI,KAAWA,EAAQuK,QACxB5L,KAAK6M,UAAU7M,KAAKwM,QAAQZ,OAInD,CAAe,MAAuB,iBAAZvK,EACPrB,KAAKwM,QAAQnL,GAEbrB,KAAKwM,OAEnB,CAID,YAAAD,CAAaQ,EAAclT,EAAUK,GACjC,MAAMN,EAAU,IAAIJ,GAAQ,SAAS4B,EAASsB,GAC1C,IACI,MAAM4P,EAAaS,EAAa5L,QAC1B6L,EAAkB,IAAIrG,MACxB,wFAMJ,IAAKoG,EAAa5L,QAEd,YADAzE,EAAOsQ,GAIX,MAAMC,EAAgBxB,GAAeC,OAAO,gBAC5C,IAAK,IAAIvS,EAAI,EAAG6M,EAAMiH,EAAc7T,OAAQD,EAAI6M,EAAK7M,IAAK,CACtD,MAAM+T,EAAmBD,EAAc9T,GAQvC,KAJoBkR,EAChBmB,GACA0B,IAGeH,EAAaG,KACc,mBAAnCH,EAAaG,GAGpB,YADAxQ,EAAOsQ,EAGd,CAED,MAAMG,EAA0B,WAC5B,MAAMC,EAA8B,SAASC,GACzC,OAAO,WACH,MAAMrT,EAAQ,IAAI2M,MACd,UAAU0G,8CAERzT,EAAUJ,EAAQkD,OAAO1C,GAK/B,OAJAL,EACIC,EACAc,UAAUA,UAAUtB,OAAS,IAE1BQ,CACnC,CACA,EAEoB,IACI,IAAIT,EAAI,EAAG6M,EAAMwF,GAAsBpS,OACvCD,EAAI6M,EACJ7M,IACF,CACE,MAAMmU,EAAuB9B,GAAsBrS,GAC9C4T,EAAaO,KACdP,EACIO,GACAF,EACAE,GAGX,CACrB,EAEgBH,IAEA,MAAMI,EAAmB,SAASC,GAC1B1C,GAAewB,IACfhS,QAAQmT,KACJ,kCAAkCnB,KAG1CxB,GAAewB,GAAcS,EAC7BhC,GAAcuB,GAAckB,EAI5BpS,GACpB,EAEoB,aAAc2R,EAEVA,EAAalL,UACoB,mBAA1BkL,EAAalL,SAEpBkL,EAAalL,WAAW/H,KAAKyT,EAAkB7Q,GAE/C6Q,IAAmBR,EAAalL,UAGpC0L,GAAiB,EAExB,CAAC,MAAOhV,GACLmE,EAAOnE,EACV,CACb,IAGQ,OADA0B,EAAoBL,EAASC,EAAUK,GAChCN,CACV,CAED,MAAAgS,GACI,OAAO5L,KAAKmB,SAAW,IAC1B,CAED,SAAAuM,CAAUpB,EAAYzS,EAAUK,GAC5B,MAAMyT,EAAmB7C,GAAewB,GAClC9S,EAAQ4B,QAAQ0P,GAAewB,IAC/B9S,EAAQkD,OAAO,IAAIiK,MAAM,sBAG/B,OADA1M,EAAoB0T,EAAkB9T,EAAUK,GACzCyT,CACV,CAED,aAAAC,CAAc/T,GACV,MAAMgU,EAAoBrU,EAAQ4B,QAAQwN,GAE1C,OADA3O,EAAoB4T,EAAmBhU,GAChCgU,CACV,CAED,KAAAlN,CAAM9G,GACF,MAAMkG,EAAOC,KAEPpG,EAAUmG,EAAK0M,WAAW3S,MAAK,KACb,OAAhBiG,EAAK4M,SACL5M,EAAK4M,OAAS5M,EAAK2M,eAGhB3M,EAAK4M,UAIhB,OADA1S,EAAoBL,EAASC,EAAUA,GAChCD,CACV,CAED,SAAAiT,CAAUiB,EAASjU,EAAUK,GACzB,MAAM6F,EAAOC,KAER2K,EAAQmD,KACTA,EAAU,CAACA,IAGf,MAAMC,EAAmB/N,KAAKgO,qBAAqBF,GAEnD,SAASG,IACLlO,EAAKyM,QAAQZ,OAAS7L,EAAK6L,QAC9B,CAED,SAASsC,EAAqBtC,GAK1B,OAJA7L,EAAKoO,QAAQvC,GACbqC,IAEAlO,EAAK4M,OAAS5M,EAAKqB,aAAarB,EAAKyM,SAC9BzM,EAAK4M,MACf,CAmCD,MAAMyB,EACkB,OAApBpO,KAAKyM,WACCzM,KAAKyM,WAAWtS,OAAM,IAAMX,EAAQ4B,YACpC5B,EAAQ4B,UAuBlB,OArBA4E,KAAKyM,WAAa2B,EACbtU,MAAK,KACF,MAAMwS,EAAayB,EAAiB,GAIpC,OAHAhO,EAAKG,QAAU,KACfH,EAAK4M,OAAS,KAEP5M,EAAK2N,UAAUpB,GAAYxS,MAAK8R,IACnC7L,EAAKoB,QAAUyK,EAAOzK,QACtB8M,IACAlO,EAAK6M,+BACL7M,EAAK2M,YAhDjB,SAAoBqB,GAChB,OAAO,WACH,IAAIM,EAAqB,EAwBzB,OAtBA,SAASC,IACL,KAAOD,EAAqBN,EAAiB3U,QAAQ,CACjD,IAAIkT,EAAayB,EAAiBM,GAMlC,OALAA,IAEAtO,EAAKG,QAAU,KACfH,EAAK4M,OAAS,KAEP5M,EACF2N,UAAUpB,GACVxS,KAAKoU,GACL/T,MAAMmU,EACd,CAEDL,IACA,MAAMjU,EAAQ,IAAI2M,MACd,sCAGJ,OADA5G,EAAK0M,WAAajT,EAAQkD,OAAO1C,GAC1B+F,EAAK0M,UACf,CAEM6B,EACvB,CACS,CAoB8BC,CAAWR,EAAiB,GACjD,IAEL5T,OAAM,KACH8T,IACA,MAAMjU,EAAQ,IAAI2M,MAAM,sCAExB,OADA5G,EAAK0M,WAAajT,EAAQkD,OAAO1C,GAC1B+F,EAAK0M,UAAU,IAG9BxS,EAAoB+F,KAAKyM,WAAY5S,EAAUK,GACxC8F,KAAKyM,UACf,CAED,QAAA+B,CAASlC,GACL,QAASvB,GAAcuB,EAC1B,CAED,OAAA6B,CAAQM,GACJxC,GAAOjM,KAAMyO,EAChB,CAED,oBAAAT,CAAqBF,GACjB,MAAMC,EAAmB,GACzB,IAAK,IAAI5U,EAAI,EAAG6M,EAAM8H,EAAQ1U,OAAQD,EAAI6M,EAAK7M,IAAK,CAChD,MAAMmT,EAAawB,EAAQ3U,GACvB6G,KAAKwO,SAASlC,IACdyB,EAAiBnR,KAAK0P,EAE7B,CACD,OAAOyB,CACV,CAED,4BAAAnB,GAKI,IAAK,IAAIzT,EAAI,EAAG6M,EAAMyF,GAAerS,OAAQD,EAAI6M,EAAK7M,IAClD0S,GAAc7L,KAAMyL,GAAetS,GAE1C,CAED,cAAAuV,CAAerN,GACX,OAAO,IAAI8K,GAAY9K,EAC1B,EAKL,IAAesN,GAAA,IAAIxC"}